var documenterSearchIndex = {"docs":
[{"location":"polygons/#Rational-Polygons","page":"Rational Polygons","title":"Rational Polygons","text":"","category":"section"},{"location":"polygons/#The-RationalPolygon-type","page":"Rational Polygons","title":"The RationalPolygon type","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"In RationalPolygons.jl, we represent a polygon P subseteq mathbbR^2 by two pieces of data: An integral matrix V in mathbbZ^2times N and an integer k in mathbbZ, called the rationality. The associated polygon has as vertices the columns of V divided by k. To represent V, we use a static matrix, which are faster than Julia's internal matrices for many common operations. ","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"The standard lattice triangle can be created as follows:","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"julia> using RationalPolygons, StaticArrays\n\njulia> P = RationalPolygon(SMatrix{2,3}([0 1 0 ; 0 0 1]), 1)\nRational polygon of rationality 1 with 3 vertices.","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"warning: Warning\nWhen creating a RationalPolygon from a constructor, the user has to be certain that the columns of V truly are vertices of a polygons, i.e. no column is contained in the convex hull of the other columns and the columns are sorted by angle (both clockwise and counterclockwise is allowed). If this is not known, use convex_hull to create the polygon instead.","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"There are two ways in which this encoding is not unique: First, scaling V and k by the same factor does not change the polygon, e.g. (Vk) describes the same polygon as (2V2k). Even though they are mathematically the same polygon, RationalPolygon.jl views them as different objects, once viewed as a k-rational polygon and once viewed as a 2k-rational polygon. The second way in which this encoding is not unique is that there is no canonical \"first vertex\" of a polygon, i.e. we can shift the columns of V around and still describe the same polygon. Moreover, we choose to order them clockwise or counterclockwise. This problem is adressed in the section on normal forms.","category":"page"},{"location":"polygons/#Constructors","page":"Rational Polygons","title":"Constructors","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"Besides the type constructor methods, we provide the functions convex_hull and intersect_halfplanes to create a polygon from an unstructured collection of points in the plane of affine halfplanes.","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"RationalPolygon\nconvex_hull\nintersect_halfplanes\nempty_polygon","category":"page"},{"location":"polygons/#RationalPolygons.RationalPolygon","page":"Rational Polygons","title":"RationalPolygons.RationalPolygon","text":"RationalPolygon{T<:Integer,N,M}\n\nThe type of rational polygons in two-dimensional space. T is the type of integers to be used. N is the number of vertices of the polygon and M equals 2*N. It has the following fields:\n\nrationality :: T: The rationality of the polygon, e.g. 1 for lattice polygons, 2 for half-integral polygons etc.\nvertex_matrix :: SMatrix{2,N,T,M}: An integral 2xN matrix. The vertices of the polygon are understood to be the columns of this matrix divided by rationality.\nnumber_of_vertices :: Int: The number of vertices of the polygon. This is redundant information, since the number of vertices is already available as the type parameter N. However, getting the number of vertices of a polygon through the type paremeter means lots of work for Julia's dispatch algorithm. Therefore, we found it to improve performance to put it as a variable into the struct as well.\nis_unimodular_normal_form :: Bool: A flag variable to remember that the polygon is already in unimodular normal form.\nis_affine_normal_form :: Bool: A flag variable to remember that the polygon is already in affine normal form.\n\n\n\n\n\n","category":"type"},{"location":"polygons/#RationalPolygons.convex_hull","page":"Rational Polygons","title":"RationalPolygons.convex_hull","text":"convex_hull(points :: Vector{LatticePoint{T}}, k :: T = one(T)) where {T <: Integer}\n\nReturn the k-rational polygon given by the convex hull of p // k, where p ∈ points.\n\n\n\n\n\nconvex_hull(points :: Vector{RationalPoint{T}}) where {T <: Integer}\n\nReturn the convex hull of a given set of rational points. The rationality will be inferred from the input.\n\nExample\n\njulia> convex_hull(RationalPoint{Int}[(1,0),(0,1//2),(0,-1//3)])\nRational polygon of rationality 6 with 3 vertices.\n\n\n\n\n\nconvex_hull(points :: Vector{RationalPoint{T}}, k :: T) where {T <: Integer}\n\nReturn the convex hull of a given set of rational points, viewed as a k-rational polygon.\n\nExample\n\njulia> convex_hull(RationalPoint{Int}[(1,0),(0,1//2),(0,-1//3)], 12)\nRational polygon of rationality 12 with 3 vertices.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.intersect_halfplanes","page":"Rational Polygons","title":"RationalPolygons.intersect_halfplanes","text":"intersect_halfplanes(halfplanes :: Vector{AffineHalfplane{T}}; rationality :: Union{Missing,T} = missing) where {T <: Integer}\n\nReturn the polygon described by the intersection of the given affine halfplanes. Throws an error if the intersection is unbounded. If rationality is not provided, it will be inferred from the input.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.empty_polygon","page":"Rational Polygons","title":"RationalPolygons.empty_polygon","text":"empty_polygon(rationality :: T) where {T <: Integer}\n\nReturn the empty polygon of given rationality.\n\n\n\n\n\nempty_polygon(::Type{T}) where {T <: Integer}\n\nReturn the empty polygon of integer type T. The rationality is understood to be one, i.e. it is a lattice polygon.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Properties","page":"Rational Polygons","title":"Properties","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"number_of_vertices\nrationality(P :: RationalPolygon)\nvertex_matrix\nis_unimodular_normal_form\nis_affine_normal_form\nscaled_vertex\nvertex\nvertices\naffine_halfplane(P :: RationalPolygon, i :: Int)\naffine_halfplanes(P :: RationalPolygon)\nBase.in(x :: Point{T}, P :: RationalPolygon{T}) where {T <: Integer}\ncontains_in_interior(x :: Point{T}, P :: RationalPolygon{T,N}) where {N,T <: Integer}\ndim\nis_primitive(P :: RationalPolygon{T,N}) where {N,T <: Integer}\nis_fano(P :: RationalPolygon)\nnormalized_area\neuclidian_area\nis_maximal\ndual\ngorenstein_index\nlog_canonicity","category":"page"},{"location":"polygons/#RationalPolygons.number_of_vertices","page":"Rational Polygons","title":"RationalPolygons.number_of_vertices","text":"number_of_vertices(P :: RationalPolygon)\n\nReturn the number of vertices of a polygon.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.rationality-Tuple{RationalPolygon}","page":"Rational Polygons","title":"RationalPolygons.rationality","text":"rationality(P :: RationalPolygon)\n\nReturn the rationality of P. Note that this does not need to be the smallest positive integer k such that k*P is a lattice polygon: The standard lattice triangle may also be viewed as a half-integral polygon, in which case the rationality would be 2, even though all vertices are integral.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#RationalPolygons.vertex_matrix","page":"Rational Polygons","title":"RationalPolygons.vertex_matrix","text":"vertex_matrix(P :: RationalPolygon)\n\nThe vertex matrix of P is the 2xN integral matrix containing the vertices of rationality(P) * P as its columns.\n\nExample\n\njulia> P = convex_hull(RationalPoint{Int}[(1,0),(0,1//2),(0,-1//3)])\nRational polygon of rationality 6 with 3 vertices.\n\njulia> vertex_matrix(P)\n2×3 StaticArraysCore.SMatrix{2, 3, Int64, 6} with indices SOneTo(2)×SOneTo(3):\n  0  6  0\n -2  0  3\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.is_unimodular_normal_form","page":"Rational Polygons","title":"RationalPolygons.is_unimodular_normal_form","text":"is_unimodular_normal_form(P :: RationalPolygon)\n\nReturn whether it is already known that P is in unimodular normal form.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.is_affine_normal_form","page":"Rational Polygons","title":"RationalPolygons.is_affine_normal_form","text":"is_affine_normal_form(P :: RationalPolygon)\n\nReturn whether it is already known that P is in affine normal form.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.scaled_vertex","page":"Rational Polygons","title":"RationalPolygons.scaled_vertex","text":"scaled_vertex(P :: RationalPolygon, i :: Int)\n\nReturn the i-th integral vertex of the polygon rationality(P) * P. The index i is regarded as a cyclic index, e.g. the N+1-th vertex is equal to the first vertex.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.vertex","page":"Rational Polygons","title":"RationalPolygons.vertex","text":"vertex(P :: RationalPolygon, i :: Int)\n\nReturn the i-th vertex of the polygon P. The index i is regarded as a cyclic index, e.g. the N+1-th vertex is equal to the first vertex.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.vertices","page":"Rational Polygons","title":"RationalPolygons.vertices","text":"vertices(P :: RationalPolygon)\n\nReturn the vertices of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.affine_halfplane-Tuple{RationalPolygon, Int64}","page":"Rational Polygons","title":"RationalPolygons.affine_halfplane","text":"affine_halfplane(P :: RationalPolygon, i :: Int)\n\nReturn the i-th describing halfplane of P.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#RationalPolygons.affine_halfplanes-Tuple{RationalPolygon}","page":"Rational Polygons","title":"RationalPolygons.affine_halfplanes","text":"affine_halfplanes(P :: RationalPolygon)\n\nReturn the describing halfplanes of P.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#Base.in-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, S} where S<:Union{Rational{T}, T}, RationalPolygon{T, N, M} where {N, M}}} where T<:Integer","page":"Rational Polygons","title":"Base.in","text":"Base.in(x :: Point{T}, P :: RationalPolygon{T}) where {T <: Integer}\n\nCheck whether a point x is contained in the polygon P.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#RationalPolygons.contains_in_interior-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{2, S} where S<:Union{Rational{T}, T}, RationalPolygon{T, N, M} where M}} where {N, T<:Integer}","page":"Rational Polygons","title":"RationalPolygons.contains_in_interior","text":"contains_in_interior(x :: Point{T}, P :: RationalPolygon{T}) where {T <: Integer}\n\nCheck whether a point x is contained in the interior of P.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#RationalPolygons.dim","page":"Rational Polygons","title":"RationalPolygons.dim","text":"dim(P :: RationalPolygon)\n\nReturn the dimension of P. For empty polygons, this returns -1. Otherwise, it returns 0, 1 or 2.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.is_primitive-Union{Tuple{RationalPolygon{T, N, M} where M}, Tuple{T}, Tuple{N}} where {N, T<:Integer}","page":"Rational Polygons","title":"RationalPolygons.is_primitive","text":"is_primitive(P :: RationalPolygon)\n\nCheck whether all vertices of the scaled lattice polygon rationality(P) * P are primitive.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#RationalPolygons.is_fano-Tuple{RationalPolygon}","page":"Rational Polygons","title":"RationalPolygons.is_fano","text":"is_fano(P :: RationalPolygon)\n\nCheck whether P is a fano polygon, i.e. is primitive and contains the origin in its interior.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#RationalPolygons.normalized_area","page":"Rational Polygons","title":"RationalPolygons.normalized_area","text":"normalized_area(P :: RationalPolygon)\n\nReturn the normalized area of a k-rational polygon, i.e. 2k^2 times its euclidian area. The result is always an integer, counting the number of standard k-rational triangles contained in P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.euclidian_area","page":"Rational Polygons","title":"RationalPolygons.euclidian_area","text":"euclidian_area(P :: RationalPolygon)\n\nReturn the euclidian area of a rational polygon.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.is_maximal","page":"Rational Polygons","title":"RationalPolygons.is_maximal","text":"is_maximal(P :: RationalPolygon)\n\nCheck whether a rational polygon is maximal among all polygons sharing the same rationality and number of interior lattice points.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.dual","page":"Rational Polygons","title":"RationalPolygons.dual","text":"dual(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the dual of a polygon P. Note that P must contain the origin in its interior.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.gorenstein_index","page":"Rational Polygons","title":"RationalPolygons.gorenstein_index","text":"gorenstein_index(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the gorenstein index of a k-rational polygon P, i.e. the smallest positive integer i such that i * dual(k * P) is a lattice polygon.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.log_canonicity","page":"Rational Polygons","title":"RationalPolygons.log_canonicity","text":"log_canonicity(P :: RationalPolygon)\n\nGiven a k-rational polygon P, return the maximal rational number 0 < ϵ ≤ 1 such that ε*P contains only one k-rational point in its interior (the origin). For a fano polygon, this equals the maximal rational number 0 < ε ≤ 1 such that the associated toric surface is ε-log canonical.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Ehrhart-Theory","page":"Rational Polygons","title":"Ehrhart Theory","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"Consider a k-rational polygon P. The main result of Ehrhart Theory is that the the number of lattice points in integral multiples of P is a quasipolynomial, called its Ehrhart quasipolynomial:","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"mathrmehr_P(t) = tP cap mathbbZ^2 = At^2 + a(t)t+b(t) qquad t in mathbbZ","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"Here, A is the euclidian area of P and a bcolon mathbbZ to mathbbQ are k-periodic functions. These can be computed by","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"a(t) = -(2t+k)cdot A + fracmathrmehr_P(t+k)-mathrmehr_P(t)k","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"b(t) = (t^2+tk)cdot A + frac(t+k)mathrmehr_P(t)-tmathrmehr_P(t+k)k","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"Setting tildeA = 2k^2A tildea = 2k^2 a and tildeb = 2k^2b, we get integer valued functions tilde a and tilde b which we call the normalized Ehrhart coefficients. We then encode the Ehrhart quasipolynomial by the 3times k integral matrix of its normalized Ehrhart coefficients:","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"beginbmatrix\ntildeA  tildea(1)  tildeb(1) \ntildeA  tildea(2)  tildeb(2) \nvdots  vdots  vdots \ntildeA  tildea(k)  tildeb(k)\nendbmatrix in mathbbZ^3times k","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"If P is integral, we have k=1 and its Ehrhart quasipolynomial is a regular polyomial of degree 2. In general, the periods of a and b are divisors of k. If they are strictly smaller than k, we speak of quasiperiod collapse. A rational polygon is called quasiintegral if the periods of a and b are both 1, hence it has an Ehrhart polynomial.","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"RationalPolygons.jl comes with many methods for counting the (interior, boundary) lattice points of a rational polygon as well as computing its Ehrhart quasipolynomial and its periods.","category":"page"},{"location":"polygons/#Counting-lattice-points","page":"Rational Polygons","title":"Counting lattice points","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"generic_lattice_points\nboundary_k_rational_points\nnumber_of_boundary_k_rational_points\nboundary_lattice_points\nnumber_of_boundary_lattice_points\ninterior_k_rational_points\nnumber_of_interior_k_rational_points\ninterior_lattice_points\nnumber_of_interior_lattice_points\nk_rational_points\nnumber_of_k_rational_points\nlattice_points\nnumber_of_lattice_points\nk_rational_hull\ninterior_k_rational_hull\ninteger_hull\ninterior_integer_hull","category":"page"},{"location":"polygons/#RationalPolygons.generic_lattice_points","page":"Rational Polygons","title":"RationalPolygons.generic_lattice_points","text":"generic_lattice_points(P :: RationalPolygon{T,N}, k :: T)\n\nReturn the lattice points in the k-fold of the rational polygon P. If the keyword argument interior = true is passed, only the interior lattice points are computed. If only_count = true is passed, only the total number of lattice points is returned.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.boundary_k_rational_points","page":"Rational Polygons","title":"RationalPolygons.boundary_k_rational_points","text":"boundary_k_rational_points(P :: RationalPolygon{T,N}, k :: T) where {N,T <: Integer}\n\nReturn all k-rational points on the boundary of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.number_of_boundary_k_rational_points","page":"Rational Polygons","title":"RationalPolygons.number_of_boundary_k_rational_points","text":"number_of_boundary_k_rational_points(P :: RationalPolygon{T}, k :: T) where {T <: Integer}\n\nReturn the number of k-rational points on the boundary of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.boundary_lattice_points","page":"Rational Polygons","title":"RationalPolygons.boundary_lattice_points","text":"boundary_lattice_points(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn all lattice points on the boundary of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.number_of_boundary_lattice_points","page":"Rational Polygons","title":"RationalPolygons.number_of_boundary_lattice_points","text":"number_of_boundary_lattice_points(P :: RationalPolygon)\n\nReturn the number of lattice points on the boundary of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.interior_k_rational_points","page":"Rational Polygons","title":"RationalPolygons.interior_k_rational_points","text":"interior_k_rational_points(P :: RationalPolygon{T}, k :: T) where {T <: Integer}\n\nReturn all k-rational points in the interior of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.number_of_interior_k_rational_points","page":"Rational Polygons","title":"RationalPolygons.number_of_interior_k_rational_points","text":"number_of_interior_k_rational_points(k :: T, P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the number of k-rational points in the interior of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.interior_lattice_points","page":"Rational Polygons","title":"RationalPolygons.interior_lattice_points","text":"interior_lattice_points(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn all lattice points in the interior of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.number_of_interior_lattice_points","page":"Rational Polygons","title":"RationalPolygons.number_of_interior_lattice_points","text":"number_of_interior_lattice_points(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the number of lattice points in the interior of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.k_rational_points","page":"Rational Polygons","title":"RationalPolygons.k_rational_points","text":"k_rational_points(k :: T, P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn all k-rational points in P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.number_of_k_rational_points","page":"Rational Polygons","title":"RationalPolygons.number_of_k_rational_points","text":"number_of_k_rational_points(P :: RationalPolygon{T}, k :: T) where {T <: Integer}\n\nReturn the number of k-rational points in P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.lattice_points","page":"Rational Polygons","title":"RationalPolygons.lattice_points","text":"lattice_points(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn all lattice points in P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.number_of_lattice_points","page":"Rational Polygons","title":"RationalPolygons.number_of_lattice_points","text":"number_of_lattice_points(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the number of lattice points in P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.k_rational_hull","page":"Rational Polygons","title":"RationalPolygons.k_rational_hull","text":"k_rational_hull(P :: RationalPolygon{T}, k :: T) where {T <: Integer}\n\nReturn the convex hull of all k-rational points contained in P. If primitive = true is passed, only the primitive k-rational points are taken.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.interior_k_rational_hull","page":"Rational Polygons","title":"RationalPolygons.interior_k_rational_hull","text":"interior_k_rational_hull(P :: RationalPolygon{T}, k :: T) where {T <: Integer}\n\nReturn the convex hull of all interior k-rational points of P. If primitive = true is passed, only the primitive k-rational points are taken.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.integer_hull","page":"Rational Polygons","title":"RationalPolygons.integer_hull","text":"integer_hull(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the convex hull of all lattice points in the interior of P. If primitive = true is passed, only the primitive interior lattice points are taken.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.interior_integer_hull","page":"Rational Polygons","title":"RationalPolygons.interior_integer_hull","text":"interior_integer_hull(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the convex hull of all interior lattice points of P. If primitive = true is passed, only the primitive lattice points are taken.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Ehrhart-quasipolynomial","page":"Rational Polygons","title":"Ehrhart quasipolynomial","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"is_periodic\nperiod\nehrhart_quasipolynomial_with_periods\nehrhart_quasipolynomial\nehrhart_quasipolynomial_periods\nehrhart_quasipolynomial_period\nis_quasiintegral","category":"page"},{"location":"polygons/#RationalPolygons.is_periodic","page":"Rational Polygons","title":"RationalPolygons.is_periodic","text":"is_periodic(v :: Vector, k :: Int)\n\nCheck if a vector v is k-periodic, i.e. v[i] == v[mod(i+k,1:n)] for all i, where n = length(v).\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.period","page":"Rational Polygons","title":"RationalPolygons.period","text":"period(v :: Vector)\n\nReturn the smallest positive integer k such that v is k-periodic.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.ehrhart_quasipolynomial_with_periods","page":"Rational Polygons","title":"RationalPolygons.ehrhart_quasipolynomial_with_periods","text":"ehrhart_quasipolynomial_with_periods(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn a k x 3-matrix of normalized coefficients of the Ehrhart quasipolynomial of a k-rational polygon P, together with a vector of it's three periods.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.ehrhart_quasipolynomial","page":"Rational Polygons","title":"RationalPolygons.ehrhart_quasipolynomial","text":"ehrhart_quasipolynomial(P :: RationalPolygon)\n\nReturn a k x 3-matrix of normalized coefficients of the Ehrhart quasipolynomial of a k-rational polygon P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.ehrhart_quasipolynomial_periods","page":"Rational Polygons","title":"RationalPolygons.ehrhart_quasipolynomial_periods","text":"ehrhart_quasipolynomial_periods(P :: RationalPolygon)\n\nReturn the periods of the Ehrhart quasipolynomial of a k-rational polygon P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.ehrhart_quasipolynomial_period","page":"Rational Polygons","title":"RationalPolygons.ehrhart_quasipolynomial_period","text":"ehrhart_quasipolynomial_period(P :: RationalPolygon)\n\nReturn the period of the Ehrhart quasipolynomial of a k-rational polygon P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.is_quasiintegral","page":"Rational Polygons","title":"RationalPolygons.is_quasiintegral","text":"is_quasiintegral(P :: RationalPolygon)\n\nCheck whether a rational polygon is quasiintegral, i.e. has an Ehrhart polynomial.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Normal-forms-and-automorphism-groups","page":"Rational Polygons","title":"Normal forms and automorphism groups","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"Two k-rational polygons are called (affine) unimodular equivalent if they can be transformed into each other by an (affine) unimodular transformation. The purpose of a normal form is to provide a unique representative for every equivalence class, i.e. two polygons should be (affine) unimodular equivalent to each other if and only if their (affine) unimodular normal forms coincide.","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"For details about the normal form used in RationalPolygons.jl, we refer to [1].","category":"page"},{"location":"polygons/#Normal-forms","page":"Rational Polygons","title":"Normal forms","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"unimodular_normal_form\nare_unimodular_equivalent\naffine_normal_form\nare_affine_equivalent","category":"page"},{"location":"polygons/#RationalPolygons.unimodular_normal_form","page":"Rational Polygons","title":"RationalPolygons.unimodular_normal_form","text":"unimodular_normal_form(P :: RationalPolygon{T,N}) where {N,T <: Integer}\n\nReturn a unimodular normal form of a rational polygon. Two rational polygons have the same unimodular normal form if and only if the can be transformed into each other by applying a unimodular transformation.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.are_unimodular_equivalent","page":"Rational Polygons","title":"RationalPolygons.are_unimodular_equivalent","text":"are_unimodular_equivalent(P :: RationalPolygon, Q :: RationalPolygon)\n\nChecks whether two rational polygons are equivalent by a unimodular transformation.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.affine_normal_form","page":"Rational Polygons","title":"RationalPolygons.affine_normal_form","text":"affine_normal_form(P :: RationalPolygon{T,N}) where {N,T <: Integer}\n\nReturn a affine normal form of a rational polygon. Two rational polygons have the same affine normal form if and only if the can be transformed into each other by applying an affine unimodular transformation.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.are_affine_equivalent","page":"Rational Polygons","title":"RationalPolygons.are_affine_equivalent","text":"are_affine_equivalent(P :: RationalPolygon, Q :: RationalPolygon)\n\nChecks whether two rational polygons are equivalent by an affine unimodular transformation.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Automorphism-groups","page":"Rational Polygons","title":"Automorphism groups","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"PolygonAutomorphismGroup\nCyclicGroup\nDihedralGroup\nis_cyclic\norder\nunimodular_automorphism_group\naffine_automorphism_group","category":"page"},{"location":"polygons/#RationalPolygons.PolygonAutomorphismGroup","page":"Rational Polygons","title":"RationalPolygons.PolygonAutomorphismGroup","text":"PolygonAutomorphismGroup\n\nA struct holding information about the automorphism group of a rational polygon. It has two fields is_cyclic :: Bool and n :: Int.\n\n\n\n\n\n","category":"type"},{"location":"polygons/#RationalPolygons.CyclicGroup","page":"Rational Polygons","title":"RationalPolygons.CyclicGroup","text":"CyclicGroup(n :: Int)\n\nReturn the cyclic group of order n, as an PolygonAutomorphismGroup.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.DihedralGroup","page":"Rational Polygons","title":"RationalPolygons.DihedralGroup","text":"DihedralGroup(n :: Int)\n\nReturn the dihedral group of order 2n, as an PolygonAutomorphismGroup.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.is_cyclic","page":"Rational Polygons","title":"RationalPolygons.is_cyclic","text":"is_cyclic(G :: PolygonAutomorphismGroup)\n\nCheck whether G is a cyclic group.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.order","page":"Rational Polygons","title":"RationalPolygons.order","text":"order(G :: PolygonAutomorphismGroup)\n\nReturn the order of the group G.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.unimodular_automorphism_group","page":"Rational Polygons","title":"RationalPolygons.unimodular_automorphism_group","text":"unimodular_automorphism_group(P :: RationalPolygon)\n\nReturn the automorphism group of P with respect to unimodular transformations.\n\nExample\n\njulia> P = convex_hull(LatticePoint{Int}[(1,0),(0,1),(-1,1),(-1,0),(0,-1),(1,-1)])\nRational polygon of rationality 1 with 6 vertices.\n\njulia> unimodular_automorphism_group(P)\nD6\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.affine_automorphism_group","page":"Rational Polygons","title":"RationalPolygons.affine_automorphism_group","text":"affine_automorphism_group(P :: RationalPolygon{T,N}) where {N,T <: Integer}\n\nReturn the automorphism group of P with respect to affine unimodular transformations.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Lattice-width","page":"Rational Polygons","title":"Lattice width","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"In [2], Bohnert describes the concept of lattice width data, which captures information about the slicing lengths of a polygon with respect to a given direction vectors. RationalPolygons.jl implements this concept, following his Definition 2.11.","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"width\nall_direction_vectors_with_width_less_than\nwidth_direction_vectors\nadjust_to_width_direction\nnumber_of_interior_integral_lines\nminimal_number_of_interior_integral_lines\nis_realizable_in_interval\nLatticeWidthData\nlattice_width_data\nnumber_of_interior_integral_vertical_lines\nposition_of_longest_vertical_slice_length\nlattice_width_datas\nnumbers_of_interior_integral_vertical_lines\npositions_of_longest_vertical_slice_length","category":"page"},{"location":"polygons/#RationalPolygons.width","page":"Rational Polygons","title":"RationalPolygons.width","text":"width(P :: RationalPolygon{T}, w :: Point{T}) where {T <: Integer}\n\nReturn the lattice width of P in direction w.\n\nExample\n\njulia> P = convex_hull(LatticePoint{Int}[(1,1),(1,-2),(-4,2),(-2,2)],2)\nRational polygon of rationality 2 with 4 vertices.\n\njulia> width(P, Point(0,1))\n2//1\n\njulia> width(P, Point(1,0))\n5//2\n\n\n\n\n\nwidth(P :: RationalPolygon)\n\nReturn the lattice width of P.\n\nExample\n\njulia> P = convex_hull(LatticePoint{Int}[(1,1),(1,-2),(-4,2),(-2,2)],2)\nRational polygon of rationality 2 with 4 vertices.\n\njulia> width(P)\n2//1\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.all_direction_vectors_with_width_less_than","page":"Rational Polygons","title":"RationalPolygons.all_direction_vectors_with_width_less_than","text":"all_direction_vectors_with_width_less_than(P :: RationalPolygon{T}, c :: Rational{T}) where {T <: Integer}\n\nReturn all direction vectors in which the width of P is less than or equal to a given constant.\n\nExample\n\njulia> P = convex_hull(LatticePoint{Int}[(1,1),(1,-2),(-4,2),(-2,2)],2)\nRational polygon of rationality 2 with 4 vertices.\n\njulia> all_direction_vectors_with_width_less_than(P, 3//1)\n4-element Vector{StaticArraysCore.SVector{2, Int64}}:\n [1, 0]\n [0, 1]\n [1, 1]\n [1, 2]\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.width_direction_vectors","page":"Rational Polygons","title":"RationalPolygons.width_direction_vectors","text":"width_direction_vectors(P :: RationalPolygon)\n\nReturn the lattice width direction vectors of P, i.e. those directions that realize the lattice width of P.\n\nExample\n\njulia> P = convex_hull(LatticePoint{Int}[(1,1),(1,-2),(-4,2),(-2,2)],2)\nRational polygon of rationality 2 with 4 vertices.\n\njulia> width_direction_vectors(P)\n2-element Vector{StaticArraysCore.SVector{2, Int64}}:\n [0, 1]\n [1, 1]\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.adjust_to_width_direction","page":"Rational Polygons","title":"RationalPolygons.adjust_to_width_direction","text":"adjust_to_width_direction(P :: RationalPolygon{T}, w :: Point{T}) where {T <: Integer}\n\nApply an affine unimodular transformation to P that transforms the given width direction vector to (1,0), see Lemma 2.10 of [2].\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.number_of_interior_integral_lines","page":"Rational Polygons","title":"RationalPolygons.number_of_interior_integral_lines","text":"number_of_interior_integral_lines(P :: RationalPolygon{T}, w :: Point{T}) where {T <: Integer}\n\nReturn the number of interior integral lines of P with respect to a given direction vector w.\n\nExample\n\njulia> P = convex_hull(RationalPoint{Int}[(1//3,-1),(4//3,2),(2//3,2),(-4//3,-1)])\nRational polygon of rationality 3 with 4 vertices.\n\njulia> number_of_interior_integral_lines(P, LatticePoint(1,0))\n3\n\njulia> number_of_interior_integral_lines(P, LatticePoint(0,1))\n2\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.minimal_number_of_interior_integral_lines","page":"Rational Polygons","title":"RationalPolygons.minimal_number_of_interior_integral_lines","text":"minimal_number_of_interior_integral_lines(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the minimal number of interior integral lines of P.\n\nExample\n\njulia> P = convex_hull(RationalPoint{Int}[(1//3,-1),(4//3,2),(2//3,2),(-4//3,-1)])\nRational polygon of rationality 3 with 4 vertices.\n\njulia> minimal_number_of_interior_integral_lines(P)\n2\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.is_realizable_in_interval","page":"Rational Polygons","title":"RationalPolygons.is_realizable_in_interval","text":"is_realizable_in_interval(P :: RationalPolygon{T}, h :: T) where {T <: Integer}\n\nCheck whether P is realizable in mathbbR times 0h. This is true if and only if minimal_number_of_interior_integral_lines is less than or equal to h-1.\n\nExample\n\njulia> P = convex_hull(RationalPoint{Int}[(1//3,-1),(4//3,2),(2//3,2),(-4//3,-1)])\nRational polygon of rationality 3 with 4 vertices.\n\njulia> is_realizable_in_interval(P,2)\nfalse\n\njulia> is_realizable_in_interval(P,3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.LatticeWidthData","page":"Rational Polygons","title":"RationalPolygons.LatticeWidthData","text":"LatticeWidthData{T <: Integer}\n\nA struct capturing information about the lattice width of a rational polygon with respect to a some width direction vector, see Definition 2.11 of [2]. It has two fields:\n\ninterval_of_nonzero_vertical_slice_length :: Tuple{Rational{T},Rational{T}},\ninterval_of_longest_vertical_slice_length :: Tuple{Rational{T},Rational{T}}.\n\n\n\n\n\n","category":"type"},{"location":"polygons/#RationalPolygons.lattice_width_data","page":"Rational Polygons","title":"RationalPolygons.lattice_width_data","text":"lattice_width_data(P :: RationalPolygon{T}, w :: Point{T}) where {T <: Integer}\n\nCompute the lattice width data of a rational polygon with respect to a given width direction vector, see Definition 2.11 of [2]. This function returns a value of type LatticeWidthData.\n\nExample\n\njulia> P = convex_hull(LatticePoint{Int}[(1,1),(1,-2),(-4,2),(-2,2)],2)\nRational polygon of rationality 2 with 4 vertices.\n\njulia> ws = width_direction_vectors(P)\n2-element Vector{StaticArraysCore.SVector{2, Int64}}:\n [0, 1]\n [1, 1]\n\njulia> lattice_width_data(P,ws[1])\nLatticeWidthData{Int64}((0//1, 2//1), (3//2, 3//2))\n\njulia> lattice_width_data(P,ws[2])\nLatticeWidthData{Int64}((0//1, 2//1), (1//2, 1//2))\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.number_of_interior_integral_vertical_lines","page":"Rational Polygons","title":"RationalPolygons.number_of_interior_integral_vertical_lines","text":"number_of_interior_integral_vertical_lines(P :: RationalPolygon, w :: Point{T}) where {T <: Integer}\n\nReturn the number of interior integral vertical lines of P with respect to a given lattice width direction vector, see Definition 2.11 of [2]. \n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.position_of_longest_vertical_slice_length","page":"Rational Polygons","title":"RationalPolygons.position_of_longest_vertical_slice_length","text":"position_of_longest_vertical_slice_length(P :: RationalPolygon, w :: Point{T}) where {T <: Integer}\n\nReturn the position of the longest vertical slicing length of P with respect to a given lattice width direction vector, see Definition 2.11 of [2]. \n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.lattice_width_datas","page":"Rational Polygons","title":"RationalPolygons.lattice_width_datas","text":"lattice_width_datas(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the lattice with datas for all lattice width direction vectors of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.numbers_of_interior_integral_vertical_lines","page":"Rational Polygons","title":"RationalPolygons.numbers_of_interior_integral_vertical_lines","text":"numbers_of_interior_integral_vertical_lines(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the number of interior integral vertical lines for all width direction vectors of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.positions_of_longest_vertical_slice_length","page":"Rational Polygons","title":"RationalPolygons.positions_of_longest_vertical_slice_length","text":"positions_of_longest_vertical_slice_length(P :: RationalPolygon{T}) where {T <: Integer}\n\nReturn the positions of the longest vertical slicing lengths for all width direction vectors of P.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#IO","page":"Rational Polygons","title":"IO","text":"","category":"section"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"RationalPolygons.jl provides two ways to save polygons to a file: The first is text-based, where polygons can be written and read to files containing one polygon per line like this:","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"[[2, 0], [1, 3], [-1, 0], [-3, -4]]\n[[1, 0], [2, 6], [-4, -9]]\n[[1, 0], [3, 5], [0, 1], [-5, -8]]\n....","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"This text-based format has the advantage of being universally understandable and easy to use. However, storing polygons as ascii strings is not very space-efficients, as they contain lots of redundant control characters. Hence we provide another way to store polygons in binary form, which uses the HDF5 format and is more suitable for large datasets. For an example session, see write_polygon_dataset.","category":"page"},{"location":"polygons/","page":"Rational Polygons","title":"Rational Polygons","text":"parse_rational_polygons\nwrite_rational_polygons\ncreate_polygon_dataset\nwrite_polygon_dataset\nread_polygon_dataset","category":"page"},{"location":"polygons/#RationalPolygons.parse_rational_polygons","page":"Rational Polygons","title":"RationalPolygons.parse_rational_polygons","text":"parse_rational_polygons(k :: T, files :: AbstractVector{String}) where {T <: Integer}\nparse_rational_polygons(k :: T, file :: String) where {T <: Integer}\n\nParse a list of files containing the vertices of a k-rational polygon. The files must have one polygon per line and the vertices must be given as a list of lists of integers, i.e. as in the following example:\n\n[[2, 0], [1, 3], [-1, 0], [-3, -4]] [[1, 0], [2, 6], [-4, -9]] [[1, 0], [3, 5], [0, 1], [-5, -8]] ....\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.write_rational_polygons","page":"Rational Polygons","title":"RationalPolygons.write_rational_polygons","text":"write_rational_polygons(Ps :: Vector{<:RationalPolygon{T}}, filepath :: String) where {T <: Integer}\n\nWrite a list of polygons to a text file. Each polygon will be written as one line containing its vertices, as in the following example:\n\n[[2, 0], [1, 3], [-1, 0], [-3, -4]] [[1, 0], [2, 6], [-4, -9]] [[1, 0], [3, 5], [0, 1], [-5, -8]] ....\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.create_polygon_dataset","page":"Rational Polygons","title":"RationalPolygons.create_polygon_dataset","text":"create_polygon_dataset(f :: Union{HDF5.File, HDF5.Group}, path :: String, N :: Int)\n\nCreate an HDF5 dataset named path for storing rational polygons with N vertices. The dataset will have an HDF5 compound datatype with 2*N integers, which are the entries of the vertex matrices stored in a column major layout. This function takes three keyword arguments:\n\nT :: Type{<:Integer}: The integer type to be used, e.g. Int64, Int32, ... The default is Int.\nchunk_size :: Int: Chunk size for HDF5. The default is 1000.\ndeflate :: Int: Deflate parameter for HDF5. The default is 3.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.write_polygon_dataset","page":"Rational Polygons","title":"RationalPolygons.write_polygon_dataset","text":"write_polygon_dataset(f :: Union{HDF5.File, HDF5.Group}, path :: String, Ps :: Vector{RationalPolygon{T,N,M}}) where {N,M,T <: Integer}\n\nWrite the polygons Ps to an HDF5 dataset named path. Creates the dataset if it does not exist already. If it does exist, the data will be appended to it.\n\nExample\n\nWrite the reflexive lattice triangles to an HDF5 file:\n\njulia> using RationalPolygons, StaticArrays, HDF5\n\njulia> Vs = SMatrix{2,3}[[1 0 -2 ; 0 1 -1], [1 1 -3 ; 0 2 -4], [1 0 -1 ; 0 1 -1],[1 0 -3 ; 0 1 -2], [1 1 -2 ; 0 3 -3]];\n\njulia> Ps = [RationalPolygon(V,1) for V ∈ Vs];\n\njulia> f = h5open(\"/tmp/reflexive_triangles.h5\", \"cw\")\n🗂️ HDF5.File: (read-write) /tmp/reflexive_triangles.h5\n\njulia> write_polygon_dataset(f, \"my_triangles\", Ps)\n\njulia> close(f)\n\nThe resulting HDF5 file can be inspected using a command line tool such as h5dump:\n\n$ h5dump /tmp/reflexive_triangles.h5 \nHDF5 \"/tmp/reflexive_triangles.h5\" {\nGROUP \"/\" {\n   DATASET \"my_triangles\" {\n      DATATYPE  H5T_COMPOUND {\n         H5T_STD_I64LE \"1\";\n         H5T_STD_I64LE \"2\";\n         H5T_STD_I64LE \"3\";\n         H5T_STD_I64LE \"4\";\n         H5T_STD_I64LE \"5\";\n         H5T_STD_I64LE \"6\";\n      }\n      DATASPACE  SIMPLE { ( 5 ) / ( H5S_UNLIMITED ) }\n      DATA {\n      (0): {\n            1,\n            0,\n            0,\n            1,\n            -2,\n            -1\n         },\n      (1): {\n            1,\n            0,\n            1,\n            2,\n            -3,\n            -4\n         },\n      (2): {\n            1,\n            0,\n            0,\n            1,\n            -1,\n            -1\n         },\n      (3): {\n            1,\n            0,\n            0,\n            1,\n            -3,\n            -2\n         },\n      (4): {\n            1,\n            0,\n            1,\n            3,\n            -2,\n            -3\n         }\n      }\n   }\n}\n}\n\nWe can read them back into RationalPolygons.jl at any time using read_polygon_dataset:\n\njulia> using RationalPolygons, HDF5\n\njulia> f = h5open(\"/tmp/reflexive_triangles.h5\", \"r\")\n🗂️ HDF5.File: (read-only) /tmp/reflexive_triangles.h5\n└─ 🔢 my_triangles\n\njulia> Ps = read_polygon_dataset(1, f, \"my_triangles\")\n5-element Vector{RationalPolygon{Int64, 3, 6}}:\n Rational polygon of rationality 1 with 3 vertices.\n Rational polygon of rationality 1 with 3 vertices.\n Rational polygon of rationality 1 with 3 vertices.\n Rational polygon of rationality 1 with 3 vertices.\n Rational polygon of rationality 1 with 3 vertices.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#RationalPolygons.read_polygon_dataset","page":"Rational Polygons","title":"RationalPolygons.read_polygon_dataset","text":"read_polygon_dataset(k :: T, f :: Union{HDF5.File, HDF5.Group}, path :: String, I...) where {T <: Integer}\n\nRead from an HDF5 dataset containing k-rational polygons.\n\n\n\n\n\n","category":"function"},{"location":"subpolygons/#Subpolygons","page":"Subpolygons","title":"Subpolygons","text":"","category":"section"},{"location":"subpolygons/","page":"Subpolygons","title":"Subpolygons","text":"Given a k-rational polygon P, we want to find all subpolygons of P up to equivalence. The algorithm used by RationalPoylgons.jl is described in section 2.3 of [1]. The main idea is to succesively remove vertices of P by computing hilbert bases.","category":"page"},{"location":"subpolygons/#Hilbert-bases","page":"Subpolygons","title":"Hilbert bases","text":"","category":"section"},{"location":"subpolygons/","page":"Subpolygons","title":"Subpolygons","text":"We follow [3] to compute hilbert bases of two-dimensional cones using Hirzebruch-Jung continued fractions.","category":"page"},{"location":"subpolygons/","page":"Subpolygons","title":"Subpolygons","text":"cls_cone_normal_form\nhirzebruch_jung\nhilbert_basis\nremove_vertex","category":"page"},{"location":"subpolygons/#RationalPolygons.cls_cone_normal_form","page":"Subpolygons","title":"RationalPolygons.cls_cone_normal_form","text":"cls_cone_normal_form(A :: Matrix2{T}) where {T <: Integer}\n\nBring a two-dimensional cone into normal form in the sense of [3]. The result is a triple (d, k, M), where d and k are the parameters of the cone and M is a 2x2 integral matrix such that M * [0 d ; 1 -k] == A\n\nExample\n\njulia> A = Matrix2(2, 1, -3, -5)\n2×2 SMatrix{2, 2, Int64, 4} with indices SOneTo(2)×SOneTo(2):\n 2  -3\n 1  -5\n\njulia> cls_cone_normal_form(A)\n(7, 5, [1 2; 0 1])\n\n\n\n\n\n","category":"function"},{"location":"subpolygons/#RationalPolygons.hirzebruch_jung","page":"Subpolygons","title":"RationalPolygons.hirzebruch_jung","text":"hirzebruch_jung(x :: T, y :: T) where {T <: Integer}\n\nReturn the Hirzebruch-Jung continued fraction associated to x // y.\n\nExample\n\nSee Example 10.2.4 of [3].\n\njulia> hirzebruch_jung(7,5)\n3-element Vector{Int64}:\n 2\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"subpolygons/#RationalPolygons.hilbert_basis","page":"Subpolygons","title":"RationalPolygons.hilbert_basis","text":"hilbert_basis(A :: Matrix2{T}) where {T <: Integer}\n\nReturn the hilbert basis of a two-dimensional cone spanned by the columns of A, which must be primitive.\n\nExample\n\nSee Example 10.2.4 of [3].\n\njulia> A = Matrix2(0,1,7,-5)\n2×2 SMatrix{2, 2, Int64, 4} with indices SOneTo(2)×SOneTo(2):\n 0   7\n 1  -5\n\njulia> hilbert_basis(A)\n5-element Vector{SVector{2, Int64}}:\n [0, 1]\n [1, 0]\n [2, -1]\n [3, -2]\n [7, -5]\n\n\n\n\n\nhilbert_basis(v1 :: LatticePoint{T}, v2 :: LatticePoint{T}) where {T <: Integer}\n\nReturn the hilbert basis of a two-dimensional cone spanned by given integral primitive vectors v1 and v2.\n\n\n\n\n\n","category":"function"},{"location":"subpolygons/#RationalPolygons.remove_vertex","page":"Subpolygons","title":"RationalPolygons.remove_vertex","text":"remove_vertex(P :: RationalPolygon{T}, i :: Int) where {T <: Integer}\n\nReturn a pair (Q, keeps_genus), where Q is the convex hull of all k-rational points of P except the i-th vertex and keeps_genus :: Bool is true if and only if Q has the same number of interior lattice points as P. If the argument primitive = true is passed, the convex hull is taken of all primitive k-rational points of P except the i-th vertex.\n\nExample\n\nCompare Example 10.2.7 of [3].\n\njulia> P = convex_hull(LatticePoint{Int}[(0,0),(7,-5),(7,1),(0,1)])\nRational polygon of rationality 1 with 4 vertices.\n\njulia> Q,_ = remove_vertex(P,1)\n(Rational polygon of rationality 1 with 4 vertices., false)\n\njulia> vertices(Q)\n4-element Vector{SVector{2, Rational{Int64}}}:\n [0, 1]\n [3, -2]\n [7, -5]\n [7, 1]\n\n\n\n\n\n","category":"function"},{"location":"subpolygons/#Computing-subpolygons","page":"Subpolygons","title":"Computing subpolygons","text":"","category":"section"},{"location":"subpolygons/","page":"Subpolygons","title":"Subpolygons","text":"Subpolygons can be either computed in memory or on disk using HDF5. The latter is useful for large computations, since the amount of data can easily overload memory.","category":"page"},{"location":"subpolygons/","page":"Subpolygons","title":"Subpolygons","text":"SubpolygonStorage\nInMemorySubpolygonStoragePreferences\nInMemorySubpolygonStorage\nHDFSubpolygonStoragePreferences\nHDFSubpolygonStorage\ninitialize_subpolygon_storage\nsubpolygons_single_step\nsubpolygons\nrestore_hdf_subpolygon_storage_status","category":"page"},{"location":"subpolygons/#RationalPolygons.SubpolygonStorage","page":"Subpolygons","title":"RationalPolygons.SubpolygonStorage","text":"SubpolygonStorage{T <: Integer}\n\nAn abstract supertype of storage options for computing subpolygons. There are two subtypes InMemorySubpolygonStorage and HDFSubpolygonStorage. The former keeps all subpolygons in memory, the latter delegeates their storage to the disk using the HDF5 format. Both implement subpolygons_single_step.\n\n\n\n\n\n","category":"type"},{"location":"subpolygons/#RationalPolygons.InMemorySubpolygonStoragePreferences","page":"Subpolygons","title":"RationalPolygons.InMemorySubpolygonStoragePreferences","text":"struct InMemorySubpolygonStoragePreferences{T <: Integer}\n\nA struct holding preferences for InMemorySubpolygonStorage. There are the following fields:\n\nprimitive :: Bool: Whether only subpolygons with primitive vertices should  be computed. The default is false.\nuse_affine_normal_form :: Bool: Whether to use affine_normal_form   or unimodular_normal_form. The default is true, i.e. affine normal   form.\nonly_equal_number_of_interior_lattice_points :: Bool: Whether only   subpolygons having the same number of interior lattice points as the starting   polygons should be computed. The default is false.\nexclude_very_thin_polygons: Whether polygons that can be realized in mathbbR times 01 should be excluded. This is only relevant for polygons with no interior lattice points. The default is false.\n\n\n\n\n\n","category":"type"},{"location":"subpolygons/#RationalPolygons.InMemorySubpolygonStorage","page":"Subpolygons","title":"RationalPolygons.InMemorySubpolygonStorage","text":"mutable struct InMemorySubpolygonStorage{T <: Integer} <: SubpolygonStorage{T}\n\nA struct holding results of a subpolygon computation. It has the following fields:\n\npreferences :: InMemorySubpolygonStoragePreferences{T}\npolygons :: Dict{T,Set{RationalPolygon{T}}}\nlast_completed_area :: T\ntotal_count :: Int\n\n\n\n\n\n","category":"type"},{"location":"subpolygons/#RationalPolygons.HDFSubpolygonStoragePreferences","page":"Subpolygons","title":"RationalPolygons.HDFSubpolygonStoragePreferences","text":"struct HDFSubpolygonStoragePreferences{T <: Integer}\n\nA struct holding preferences for HDFSubpolygonStorage. There are the following fields:\n\nrationality :: T: The rationality of the polygons. The default is one(T).\nprimitive :: Bool: Whether only subpolygons with primitive vertices should  be computed. The default is false.\nuse_affine_normal_form :: Bool: Whether to use affine_normal_form   or unimodular_normal_form. The default is true, i.e. affine normal   form.\nonly_equal_number_of_interior_lattice_points :: Bool: Whether only   subpolygons having the same number of interior lattice points as the starting   polygons should be computed. The default is false.\nexclude_very_thin_polygons: Whether polygons that can be realized in mathbbR times 01 should be excluded. This is only relevant for polygons with no interior lattice points. The default is false.\nblock_size :: Int: How many polygons should be read into memory at once   during the shaving process. Defaults to 10^6.\nmaximum_number_of_vertices :: Int: An upper bound for the maximal number of   vertices to be expected in the computation. This has to be set since every   HDF5 file generated will have a dataset \"numbers_of_polygons\" storing the   number of polygons for each number of vertices and the size of this dataset   needs to be set beforehand. Defaults to 100, which should be more than enough for any   feasable computation.\nswmr :: Bool: Whether to use single-reader-multiple-writer mode for HDF5.   Defaults to true.\n\n\n\n\n\n","category":"type"},{"location":"subpolygons/#RationalPolygons.HDFSubpolygonStorage","page":"Subpolygons","title":"RationalPolygons.HDFSubpolygonStorage","text":"mutable struct HDFSubpolygonStorage{T <: Integer} <: SubpolygonStorage{T}\n\nA struct for managing the result of a subpolygon computation using the HDF5 file format. It has the following fields:\n\npreferences :: HDFSubpolygonStoragePreferences{T}\nfile_path :: String: The file path of the HDF5 file to be created.\ngroup_path :: String: Path to a group within the HDF5 file, if it already  exists. Defaults to \"/\", i.e. the root group.\nhash_sets :: Dict{T,Set{UInt128}}: A dictionary of hashes of polygons  already encountered. This is used for comparison with new polygons to ensure  the result contains each polygon exactly once. We hold these hashes in memory  to avoid needing to read in polygons that have been written out in the past,  which saves a lot of time.\nlast_completed_area :: T: The last area that has been completed. This  counts down from the maximum area of the starting polygons to 1.\ntotal_count :: Int\n\n\n\n\n\n","category":"type"},{"location":"subpolygons/#RationalPolygons.initialize_subpolygon_storage","page":"Subpolygons","title":"RationalPolygons.initialize_subpolygon_storage","text":"initialize_subpolygon_storage(st :: HDFSubpolygonStorage{T}, Ps :: Vector{<:RationalPolygon{T}}) where {T <: Integer}\n\nInitialize a newly created HDFSubpolygonStorage with a given set of starting polygons. To restart an interrupted computation, see also restore_hdf_subpolygon_storage_status.\n\n\n\n\n\n","category":"function"},{"location":"subpolygons/#RationalPolygons.subpolygons_single_step","page":"Subpolygons","title":"RationalPolygons.subpolygons_single_step","text":"subpolygons_single_step(st :: InMemorySubpolygonStorage{T}; logging :: Bool = false) where {T <: Integer}\n\nPerform a single step of a subpolygon computation in memory.\n\n\n\n\n\nsubpolygons_single_step(st :: HDFSubpolygonStorage{T}; logging :: Bool = false) where {T <: Integer}\n\nPerform a single step in a subpolygon computation using the HDF5 file format.\n\n\n\n\n\n","category":"function"},{"location":"subpolygons/#RationalPolygons.subpolygons","page":"Subpolygons","title":"RationalPolygons.subpolygons","text":"subpolygons(st :: SubpolygonStorage{T}; logging :: Bool = false) where {T <: Integer}\n\nCompute all subpolygons with the given storage option.\n\n\n\n\n\nsubpolygons(Ps :: Vector{<:RationalPolygon{T}}) where {T <: Integer}\nsubpolygons(P :: RationalPolygon{T}) where {T <: Integer}\n\nCompute all subpolygons of a rational polygon or list of rational polygons. The computation is done in memory, for storage on disk see also HDFSubpolygonStorage. This function takes the following keyword arguments:\n\nprimitive :: Bool: Whether only subpolygons with primitive vertices should   be returned. The default is false.\nuse_affine_normal_form :: Bool: Whether to use affine or unimodular normal   form. The default is true, so affine normal form.\nonly_equal_number_of_interior_lattice_points :: Bool: Whether only   subpolygons that share the same number of interior lattice points with the   starting polygons should be returned.\nlogging :: Bool: Whether to display logging messages about the computation   progress.\n\nExample\n\nThere are 148 subpolygons of the square of side length 3, up to affine equivalence. The maximal number of vertices of those is 8, attained by exactly one polygon.\n\njulia> Ps = subpolygons(convex_hull(LatticePoint{Int}[(0,0),(3,0),(0,3),(3,3)]));\n\njulia> length(Ps)\n148\n\njulia> maximum(number_of_vertices.(Ps))\n8\n\n\n\n\n\n","category":"function"},{"location":"subpolygons/#RationalPolygons.restore_hdf_subpolygon_storage_status","page":"Subpolygons","title":"RationalPolygons.restore_hdf_subpolygon_storage_status","text":"restore_hdf_subpolygon_storage_status(st :: HDFSubpolygonStorage{T}) where {T <: Integer}\n\nRestore a subpolygons computation's status that was interrupted from an HDF5 file. All polygons will be read in, hashed and saved into st.hash_sets. Moreover, st.last_completed_area and st.total_count will be properly set. After calling this function, the computation can be resumed by calling subpolygons(st) again.\n\n\n\n\n\n","category":"function"},{"location":"docs_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docs_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"classifications/#Classifications","page":"Classifications","title":"Classifications","text":"","category":"section"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"RationalPolygons.jl implements the following classification algorithms:","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"Lattice polygons by number of lattice points from R.J. Koelman [4],\nLattice polygons by number of interior lattice points from Castryck [5],\nLattice polygons contained in a square from Brown and Kasprzyk [6],","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"Moreover, the classifications from [1] are implemented:","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"Maximal rational polygons contained in mathbbRtimes-11,\nMaximal rational polygons with no interior lattice points,\nRational polygons with one interior lattice point,\nAlmost k-hollow LDP polygons.","category":"page"},{"location":"classifications/#Lattice-polygons-by-number-of-lattice-points","page":"Classifications","title":"Lattice polygons by number of lattice points","text":"","category":"section"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"In his PhD thesis, R.J. Koelman describes an algorithm to classify lattice polygons with a given number of lattice points and ran it up to 42 lattice points, Table 4.4.3 of [4]. We have implemented his algorithm here, which sucessfully reproduces Koelman's original numbers, see also A371917 on OEIS","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"height_one_points\nsingle_point_extensions\nKoelmanStorage\nInMemoryKoelmanStorage\nHDFKoelmanStoragePreferences\nHDFKoelmanStorage\nclassify_next_number_of_lattice_points\nclassify_polygons_by_number_of_lattice_points","category":"page"},{"location":"classifications/#RationalPolygons.height_one_points","page":"Classifications","title":"RationalPolygons.height_one_points","text":"height_one_points(P :: RationalPolygon)\n\nGiven a lattice polygon P, return all lattice points that have lattice height one with respect to some edge of P. Equivalently, return the set of boundary lattice points of move_out_edges(P).\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.single_point_extensions","page":"Classifications","title":"RationalPolygons.single_point_extensions","text":"single_point_extensions(Ps :: Vector{<:RationalPolygon{T}}) where {T <: Integer}\n\nReturn all lattice polygons that can be obtained by adding a single height one point to a polygon of Ps, up to affine equivalence.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.KoelmanStorage","page":"Classifications","title":"RationalPolygons.KoelmanStorage","text":"abstract type KoelmanStorage{T <: Integer} end\n\nAbstract supertype of InMemoryKoelmanStorage and HDFKoelmanStorage. Both implement classify_next_number_of_lattice_points, which performs a single step in Koelman's classification of lattice polygons.\n\n\n\n\n\n","category":"type"},{"location":"classifications/#RationalPolygons.InMemoryKoelmanStorage","page":"Classifications","title":"RationalPolygons.InMemoryKoelmanStorage","text":"mutable struct InMemoryKoelmanStorage{T <: Integer} <: KoelmanStorage{T}\n\nA struct holding classification results of Koelman's classification of lattice polygons by number of lattice points. It has two fields polygons :: Vector{Vector{RationalPolygon{T}} and total_count :: Int.\n\n\n\n\n\n","category":"type"},{"location":"classifications/#RationalPolygons.HDFKoelmanStoragePreferences","page":"Classifications","title":"RationalPolygons.HDFKoelmanStoragePreferences","text":"struct HDFKoelmanStoragePreferences{T <: Integer}\n\nA struct holding preferences for Koelman's classification using the HDF5 file format. It has four fields:\n\nswmr :: Bool: Whether to use single-reader-multiple-writer mode for HDF5.   Defaults to true.\nmaximum_number_of_vertices :: Int: An upper bound for the maximal number of   vertices to be expected in the classification. This has to be set since every   HDF5 file generated will have a dataset \"numbers_of_polygons\" storing the   number of polygons for each number of vertices and the size of this dataset   needs to be set beforehand. Defaults to 100, which should be more than enough for any   feasable computation.\nblock_size :: Int: How many polygons should be read into memory at once   during the extension process. Defaults to 10^6.\n\n\n\n\n\n","category":"type"},{"location":"classifications/#RationalPolygons.HDFKoelmanStorage","page":"Classifications","title":"RationalPolygons.HDFKoelmanStorage","text":"mutable struct HDFKoelmanStorage{T <: Integer} <: KoelmanStorage{T}\n\nA struct for managing classification results of Koelman's classification of lattice polygons using the HDF5 file format. It has the following fields:\n\npreferences :: HDFKoelmanStoragePreferences{T}\ndirectory_path :: String: The directory where the HDF5 files will be generated.\nlast_completed_number_of_lattice_points :: Int: The last completed step of the classification. Initially, this will be 3.\ntotal_count :: Int\n\n\n\n\n\n","category":"type"},{"location":"classifications/#RationalPolygons.classify_next_number_of_lattice_points","page":"Classifications","title":"RationalPolygons.classify_next_number_of_lattice_points","text":"classify_next_number_of_lattice_points(st :: InMemoryKoelmanStorage{T}) where {T <: Integer}\n\nPerform a single step in Koelman's classification of lattice polygons using in-memory storage.\n\nExample\n\nPerform a single step of Koelmans classification using Int64. The result tells us that there are three lattice polygons with exactly four lattice points.\n\njulia> st = InMemoryKoelmanStorage{Int64}();\n\njulia> classify_next_number_of_lattice_points(st)\n3\n\njulia> st.polygons[4]\n3-element Vector{RationalPolygon{Int64}}:\n Rational polygon of rationality 1 with 3 vertices.\n Rational polygon of rationality 1 with 4 vertices.\n Rational polygon of rationality 1 with 3 vertices.\n\n\n\n\n\n\nclassify_next_number_of_lattice_points(st :: HDFKoelmanStorage{T}; logging :: Bool = false) where {T <: Integer}\n\nPerform a single step in Koelman's classification of lattice polygons using on-disk storage with HDF5.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_polygons_by_number_of_lattice_points","page":"Classifications","title":"RationalPolygons.classify_polygons_by_number_of_lattice_points","text":"classify_polygons_by_number_of_lattice_points(st :: KoelmanStorage{T}, max_number_of_lattice_points :: Int; logging :: Bool = false) where {T <: Integer}\n\nRun Koelman's classification of lattice polygons by number of lattice points, up to max_number_of_lattice_points. The classification is multithreaded, so make sure julia has access to a good number of threads for maximum performance (i.e. Threads.nthreads() is greater than one).\n\nExample\n\nReproduce Koelman's original classification in memory, see Table 4.4.3 of [4] or A371917 on OEIS. This should not take longer than a few minutes on modern hardware.\n\njulia> st = InMemoryKoelmanStorage{Int}();\n\njulia> classify_polygons_by_number_of_lattice_points(st, 42; logging=true);\n[ Info: [l = 4]. New polygons: 3. Total: 4\n[ Info: [l = 5]. New polygons: 6. Total: 10\n[ Info: [l = 6]. New polygons: 13. Total: 23\n[ Info: [l = 7]. New polygons: 21. Total: 44\n[ Info: [l = 8]. New polygons: 41. Total: 85\n[ Info: [l = 9]. New polygons: 67. Total: 152\n[ Info: [l = 10]. New polygons: 111. Total: 263\n[ Info: [l = 11]. New polygons: 175. Total: 438\n[ Info: [l = 12]. New polygons: 286. Total: 724\n[ Info: [l = 13]. New polygons: 419. Total: 1143\n[ Info: [l = 14]. New polygons: 643. Total: 1786\n[ Info: [l = 15]. New polygons: 938. Total: 2724\n[ Info: [l = 16]. New polygons: 1370. Total: 4094\n[ Info: [l = 17]. New polygons: 1939. Total: 6033\n[ Info: [l = 18]. New polygons: 2779. Total: 8812\n[ Info: [l = 19]. New polygons: 3819. Total: 12631\n[ Info: [l = 20]. New polygons: 5293. Total: 17924\n[ Info: [l = 21]. New polygons: 7191. Total: 25115\n[ Info: [l = 22]. New polygons: 9752. Total: 34867\n[ Info: [l = 23]. New polygons: 12991. Total: 47858\n[ Info: [l = 24]. New polygons: 17321. Total: 65179\n[ Info: [l = 25]. New polygons: 22641. Total: 87820\n[ Info: [l = 26]. New polygons: 29687. Total: 117507\n[ Info: [l = 27]. New polygons: 38533. Total: 156040\n[ Info: [l = 28]. New polygons: 49796. Total: 205836\n[ Info: [l = 29]. New polygons: 63621. Total: 269457\n[ Info: [l = 30]. New polygons: 81300. Total: 350757\n[ Info: [l = 31]. New polygons: 102807. Total: 453564\n[ Info: [l = 32]. New polygons: 129787. Total: 583351\n[ Info: [l = 33]. New polygons: 162833. Total: 746184\n[ Info: [l = 34]. New polygons: 203642. Total: 949826\n[ Info: [l = 35]. New polygons: 252898. Total: 1202724\n[ Info: [l = 36]. New polygons: 313666. Total: 1516390\n[ Info: [l = 37]. New polygons: 386601. Total: 1902991\n[ Info: [l = 38]. New polygons: 475540. Total: 2378531\n[ Info: [l = 39]. New polygons: 582216. Total: 2960747\n[ Info: [l = 40]. New polygons: 710688. Total: 3671435\n[ Info: [l = 41]. New polygons: 863552. Total: 4534987\n[ Info: [l = 42]. New polygons: 1048176. Total: 5583163\n\nExample\n\nReproduce Koelman's classification and storing the output to HDF5 files.\n\njulia> st = HDFKoelmanStorage{Int}(\"/tmp\");\n\njulia> classify_polygons_by_number_of_lattice_points(st, 42);\n\nThe result will be HDF5 files named \"l1.h5, l2.h5, ...\", each containing one dataset of polygons for fixed number of vertices as well as a dataset \"numbers_of_polygons\" holding their numbers.\n\njulia> using HDF5\n\njulia> f = h5open(\"/tmp/test/l42.h5\", \"r\")\n🗂️ HDF5.File: (read-only) /tmp/test/l42.h5\n├─ 🔢 n10\n├─ 🔢 n11\n├─ 🔢 n12\n├─ 🔢 n3\n├─ 🔢 n4\n├─ 🔢 n5\n├─ 🔢 n6\n├─ 🔢 n7\n├─ 🔢 n8\n├─ 🔢 n9\n└─ 🔢 numbers_of_polygons\n\njulia> A = read_dataset(f, \"numbers_of_polygons\");\n\njulia> sum(A) # the number of lattice polygons with 42 lattice points\n1048176\n\njulia> Ps = read_polygon_dataset(1, f, \"n5\"); # Read in all pentagons with 42 lattice points.\n\njulia> all(P -> number_of_lattice_points(P) == 42, Ps)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"classifications/#Lattice-polygons-by-number-of-interior-lattice-points","page":"Classifications","title":"Lattice polygons by number of interior lattice points","text":"","category":"section"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"In [5], Castryck describes an algorithm for the classification of lattice polygons by their number of interior lattice points and ran it up to 30 interior lattice points. Our implementation here successfully reproduces his numbers from Table 1 of [5], see also A322343 on OEIS.","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"classify_maximal_lattice_polygons_with_collinear_interior_points\nclassify_maximal_lattice_polygons_with_two_dimensional_empty_fine_interior\nCastryckStorage\nInMemoryCastryckStorage\nHDFCastryckStoragePreferences\nHDFCastryckStorage\nclassify_next_genus\nclassify_lattice_polygons_by_genus","category":"page"},{"location":"classifications/#RationalPolygons.classify_maximal_lattice_polygons_with_collinear_interior_points","page":"Classifications","title":"RationalPolygons.classify_maximal_lattice_polygons_with_collinear_interior_points","text":"classify_maximal_lattice_polygons_with_collinear_interior_points(i :: Int, T :: Type{<:Integer} = Int)\n\nReturn all maximal lattice polygons with i collinear interior lattice points.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_maximal_lattice_polygons_with_two_dimensional_empty_fine_interior","page":"Classifications","title":"RationalPolygons.classify_maximal_lattice_polygons_with_two_dimensional_empty_fine_interior","text":"classify_maximal_lattice_polygons_with_two_dimensional_empty_fine_interior(i :: Int, T :: Type{<:Integer} = Int)\n\nReturn all maximal lattice polygons with i interior lattice points, where the convex hull of these points is a two-dimensional lattice polygon without interior lattice points.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.CastryckStorage","page":"Classifications","title":"RationalPolygons.CastryckStorage","text":"abstract type CastryckStorage{T <: Integer} end\n\nAbstract supertype of InMemoryCastryckStorage and HDFCastryckStorage. Both implement classify_next_genus, which performs a single step in Castryck's classification of lattice polygons.\n\n\n\n\n\n","category":"type"},{"location":"classifications/#RationalPolygons.InMemoryCastryckStorage","page":"Classifications","title":"RationalPolygons.InMemoryCastryckStorage","text":"mutable struct InMemoryCastryckStorage{T <: Integer} <: CastryckStorage{T}\n\nA struct holding classification results of Castryck's classification of lattice polygons by number of interior lattice points (i.e. their genus). It has the following fields:\n\nmaximum_genus :: Int: An upper bound for the maximum genus that the  classification should run to. Defaults to 100.\nmaximal_polygons :: Vector{Vector{RationalPolygon{T}}},\nall_polygons :: Vector{Vector{RationalPolygon{T}}},\ntotal_count :: Int.\n\n\n\n\n\n","category":"type"},{"location":"classifications/#RationalPolygons.HDFCastryckStoragePreferences","page":"Classifications","title":"RationalPolygons.HDFCastryckStoragePreferences","text":"struct HDFCastryckStoragePreferences{T <: Integer}\n\nA struct holding preferences for Castryck's classification using the HDF5 file format. It has four fields:\n\nswmr :: Bool: Whether to use single-reader-multiple-writer mode for HDF5.   Defaults to true.\nmaximum_genus :: Int: An upper bound for the maximal number of interior   lattice points to which the classification should be run. Defaults to 100.\nmaximum_number_of_vertices :: Int: An upper bound for the maximal number of   vertices to be expected in the classification. This has to be set since every   HDF5 file generated will have a dataset \"numbers_of_polygons\" storing the   number of polygons for each number of vertices and the size of this dataset   needs to be set beforehand. Defaults to 100, which should be more than enough for any   feasable computation.\nblock_size :: Int: How many polygons should be read into memory at once   during the computation of subpolygons and the moving-out process. Defaults to   10^6.\n\n\n\n\n\n","category":"type"},{"location":"classifications/#RationalPolygons.HDFCastryckStorage","page":"Classifications","title":"RationalPolygons.HDFCastryckStorage","text":"mutable struct HDFCastryckStorage{T <: Integer} <: CastryckStorage{T}\n\nA struct for managing classification results of Castryck's classification of lattice polygons using the HDF5 file format. It has the following fields:\n\npreferences :: HDFCastryckStoragePreferences{T}\ndirectory_path :: String: The directory where the HDF5 files will be generated.\nlast_completed_genus :: Int: The last completed step of the classification. Initially, this will be 0.\ntotal_count :: Int\n\n\n\n\n\n","category":"type"},{"location":"classifications/#RationalPolygons.classify_next_genus","page":"Classifications","title":"RationalPolygons.classify_next_genus","text":"classify_next_genus(st :: InMemoryCastryckStorage{T}; logging :: Bool = false) where {T <: Integer}\n\nPerform a single step in Castryck's classification of lattice polygons by number of interior lattice points, using in-memory storage. Returns a tuple where the first entry is the number of lattice polygons obtained and the second number is the number of maximal lattice polygons.\n\nExample\n\nPerform two steps in Castryck's classification. The result tells us that there are 45 lattice polygons with exactly two interior lattice points, four of which are maximal.\n\njulia> st = InMemoryCastryckStorage{Int}();\n\njulia> classify_next_genus(st)\n(16, 3)\n\njulia> classify_next_genus(st)\n(45, 4)\n\n\n\n\n\nclassify_next_genus(st :: HDFCastryckStorage{T}; logging :: Bool = false) where {T <: Integer}\n\nPerform a single step in Castryck's classification of lattice polygons using on-disk storage with HDF5.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_lattice_polygons_by_genus","page":"Classifications","title":"RationalPolygons.classify_lattice_polygons_by_genus","text":"classify_lattice_polygons_by_genus(st :: CastryckStorage{T}, max_genus :: Int; logging :: Bool = false) where {T <: Integer}\n\nRun Castryck's classification of lattice polygons by number of interior lattice points, up to max_genus. The classification is multithreaded, so make sure julia has access to a good number of threads for maximum performance (i.e. Threads.nthreads() is greater than one).\n\nExample\n\nReproduce Castryck's classification in memory, see Table 1 of [5] or A322343 on OEIS. This should not take longer than a few minutes on modern hardware.\n\njulia> st = InMemoryCastryckStorage{Int}();\n\njulia> classify_lattice_polygons_by_genus(st, 30; logging=true)\n[ Info: [i = 1]. Got 3 maximal polygons.\n[ Info: [i = 1]. Subpolygons complete. Num of polygons: 16\n[ Info: [i = 1]. Moving out complete. New maximal polygons: 16\n[ Info: [i = 2]. Got 4 maximal polygons.\n[ Info: [i = 2]. Subpolygons complete. Num of polygons: 45\n[ Info: [i = 2]. Moving out complete. New maximal polygons: 22\n[ Info: [i = 3]. Got 6 maximal polygons.\n[ Info: [i = 3]. Subpolygons complete. Num of polygons: 120\n[ Info: [i = 3]. Moving out complete. New maximal polygons: 63\n[ Info: [i = 4]. Got 9 maximal polygons.\n[ Info: [i = 4]. Subpolygons complete. Num of polygons: 211\n[ Info: [i = 4]. Moving out complete. New maximal polygons: 78\n[ Info: [i = 5]. Got 11 maximal polygons.\n[ Info: [i = 5]. Subpolygons complete. Num of polygons: 403\n[ Info: [i = 5]. Moving out complete. New maximal polygons: 122\n[ Info: [i = 6]. Got 13 maximal polygons.\n[ Info: [i = 6]. Subpolygons complete. Num of polygons: 714\n[ Info: [i = 6]. Moving out complete. New maximal polygons: 192\n[ Info: [i = 7]. Got 16 maximal polygons.\n[ Info: [i = 7]. Subpolygons complete. Num of polygons: 1023\n[ Info: [i = 7]. Moving out complete. New maximal polygons: 239\n[ Info: [i = 8]. Got 21 maximal polygons.\n[ Info: [i = 8]. Subpolygons complete. Num of polygons: 1830\n[ Info: [i = 8]. Moving out complete. New maximal polygons: 316\n[ Info: [i = 9]. Got 27 maximal polygons.\n[ Info: [i = 9]. Subpolygons complete. Num of polygons: 2700\n[ Info: [i = 9]. Moving out complete. New maximal polygons: 508\n[ Info: [i = 10]. Got 33 maximal polygons.\n[ Info: [i = 10]. Subpolygons complete. Num of polygons: 3659\n[ Info: [i = 10]. Moving out complete. New maximal polygons: 509\n[ Info: [i = 11]. Got 38 maximal polygons.\n[ Info: [i = 11]. Subpolygons complete. Num of polygons: 6125\n[ Info: [i = 11]. Moving out complete. New maximal polygons: 700\n[ Info: [i = 12]. Got 51 maximal polygons.\n[ Info: [i = 12]. Subpolygons complete. Num of polygons: 8101\n[ Info: [i = 12]. Moving out complete. New maximal polygons: 1044\n[ Info: [i = 13]. Got 61 maximal polygons.\n[ Info: [i = 13]. Subpolygons complete. Num of polygons: 11027\n[ Info: [i = 13]. Moving out complete. New maximal polygons: 1113\n[ Info: [i = 14]. Got 76 maximal polygons.\n[ Info: [i = 14]. Subpolygons complete. Num of polygons: 17280\n[ Info: [i = 14]. Moving out complete. New maximal polygons: 1429\n[ Info: [i = 15]. Got 86 maximal polygons.\n[ Info: [i = 15]. Subpolygons complete. Num of polygons: 21499\n[ Info: [i = 15]. Moving out complete. New maximal polygons: 2052\n[ Info: [i = 16]. Got 113 maximal polygons.\n[ Info: [i = 16]. Subpolygons complete. Num of polygons: 28689\n[ Info: [i = 16]. Moving out complete. New maximal polygons: 1962\n[ Info: [i = 17]. Got 129 maximal polygons.\n[ Info: [i = 17]. Subpolygons complete. Num of polygons: 43012\n[ Info: [i = 17]. Moving out complete. New maximal polygons: 2651\n[ Info: [i = 18]. Got 166 maximal polygons.\n[ Info: [i = 18]. Subpolygons complete. Num of polygons: 52736\n[ Info: [i = 18]. Moving out complete. New maximal polygons: 3543\n[ Info: [i = 19]. Got 200 maximal polygons.\n[ Info: [i = 19]. Subpolygons complete. Num of polygons: 68557\n[ Info: [i = 19]. Moving out complete. New maximal polygons: 3638\n[ Info: [i = 20]. Got 240 maximal polygons.\n[ Info: [i = 20]. Subpolygons complete. Num of polygons: 97733\n[ Info: [i = 20]. Moving out complete. New maximal polygons: 4594\n[ Info: [i = 21]. Got 281 maximal polygons.\n[ Info: [i = 21]. Subpolygons complete. Num of polygons: 117776\n[ Info: [i = 21]. Moving out complete. New maximal polygons: 5996\n[ Info: [i = 22]. Got 352 maximal polygons.\n[ Info: [i = 22]. Subpolygons complete. Num of polygons: 152344\n[ Info: [i = 22]. Moving out complete. New maximal polygons: 6364\n[ Info: [i = 23]. Got 403 maximal polygons.\n[ Info: [i = 23]. Subpolygons complete. Num of polygons: 209409\n[ Info: [i = 23]. Moving out complete. New maximal polygons: 7922\n[ Info: [i = 24]. Got 506 maximal polygons.\n[ Info: [i = 24]. Subpolygons complete. Num of polygons: 248983\n[ Info: [i = 24]. Moving out complete. New maximal polygons: 9692\n[ Info: [i = 25]. Got 584 maximal polygons.\n[ Info: [i = 25]. Subpolygons complete. Num of polygons: 319957\n[ Info: [i = 25]. Moving out complete. New maximal polygons: 10208\n[ Info: [i = 26]. Got 708 maximal polygons.\n[ Info: [i = 26]. Subpolygons complete. Num of polygons: 420714\n[ Info: [i = 26]. Moving out complete. New maximal polygons: 12727\n[ Info: [i = 27]. Got 821 maximal polygons.\n[ Info: [i = 27]. Subpolygons complete. Num of polygons: 497676\n[ Info: [i = 27]. Moving out complete. New maximal polygons: 15431\n[ Info: [i = 28]. Got 995 maximal polygons.\n[ Info: [i = 28]. Subpolygons complete. Num of polygons: 641229\n[ Info: [i = 28]. Moving out complete. New maximal polygons: 15918\n[ Info: [i = 29]. Got 1121 maximal polygons.\n[ Info: [i = 29]. Subpolygons complete. Num of polygons: 813814\n[ Info: [i = 29]. Moving out complete. New maximal polygons: 20354\n[ Info: [i = 30]. Got 1352 maximal polygons.\n[ Info: [i = 30]. Subpolygons complete. Num of polygons: 957001\n[ Info: [i = 30]. Moving out complete. New maximal polygons: 23873\n\nExample\n\nReproduce Castryck's classification and storing the output to HDF5 files\n\njulia> st = HDFCastryckStorage{Int}(\"/tmp\");\n\njulia> classify_lattice_polygons_by_genus(st, 30);\n\nThis will create two directories \"all\" and \"maximal\" in the target directory and populate them with HDF5 files \"i1.h5, i2.h5, ...\" containing the polygons. The files in \"maximal\" contain datasets ordered by number of vertices. The files in \"all\" contain groups ordered by area, which contain datasets ordered by number of vertices. Every h5 file additionally contains a dataset \"numbers_of_polygons\".\n\njulia> using HDF5\n\njulia> f = h5open(\"/tmp/all/i30.h5\", \"r\");\n\njulia> Ps = read_polygon_dataset(1, f, \"a69/n8\"); # Read in all octagons of genus 30 with normalized volume 69\n\njulia> all(P -> number_of_interior_lattice_points(P) == 30, Ps)\ntrue\n\njulia> A = read_dataset(f, \"numbers_of_polygons\"); # The total number of lattice polygons with 30 interior lattice points\n\njulia> sum(A) # The total number of lattice polygons with 30 interior lattice points.\n957001\n\n\n\n\n\n","category":"function"},{"location":"classifications/#Lattice-polygons-contained-in-a-square","page":"Classifications","title":"Lattice polygons contained in a square","text":"","category":"section"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"In [6], the authors considered lattice polygons that are contained in a square of fixed side length and classified them up to side length 7. Their numbers (Table 1 of [6], see also A374975) can be reproduced with RationalPolygons.jl as follows:","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"julia> square(m) = convex_hull(LatticePoint{Int}[(0,0),(m,0),(0,m),(m,m)])\nsquare (generic function with 1 method)\n\njulia> Pss = [subpolygons(square(m); use_affine_normal_form = true, only_equal_number_of_interior_lattice_points = false) for m = 1 : 7];\n\njulia> numbers_of_polygons = [length(Pss[m]) - length(Pss[m-1]) for m = 2 : 7]\n6-element Vector{Int64}:\n      15\n     131\n    1369\n   13842\n  129185\n 1104895\n\njulia> max_vertices = [maximum(number_of_vertices.(Pss[m])) for m = 1 : 7]\n7-element Vector{Int64}:\n  4\n  6\n  8\n  9\n 10\n 12\n 13\n\njulia> [length(filter(P -> number_of_vertices(P) == max_vertices[m], Pss[m])) for m = 1 : 7]\n7-element Vector{Int64}:\n  1\n  1\n  1\n  1\n 15\n  2\n  3","category":"page"},{"location":"classifications/#Maximal-rational-polygons-contained-in-\\mathbb{R}\\times[-1,1]","page":"Classifications","title":"Maximal rational polygons contained in mathbbRtimes-11","text":"","category":"section"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"Here we provide an implementation for Algorithm 3.4 of [1].","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"classify_maximal_polygons_m1p1","category":"page"},{"location":"classifications/#RationalPolygons.classify_maximal_polygons_m1p1","page":"Classifications","title":"RationalPolygons.classify_maximal_polygons_m1p1","text":"classify_maximal_polygons_m1p1(k :: T, i :: Int)\n\nReturn all maximal k-rational polygons with i interior lattice points that can be realized in mathbbR times -11.\n\nExample\n\nCompute the numbers of polygons for 1 ≤ k ≤ 5 and 0 ≤ i ≤ 10. \n\njulia> [length(classify_maximal_polygons_m1p1(k,i)) for k = 1 : 5, i = 0 :10]\n5×11 Matrix{Int64}:\n  1    2    4    5    6    7    8    9   10   11   12\n  4    9   13   18   22   26   30   34   38   42   46\n 12   26   41   54   68   81   94  107  120  133  146\n 24   57   86  117  145  174  203  231  259  288  316\n 54  132  209  280  353  422  493  562  631  701  771\n\n\n\n\n\n","category":"function"},{"location":"classifications/#Maximal-rational-polygons-with-no-interior-lattice-points","page":"Classifications","title":"Maximal rational polygons with no interior lattice points","text":"","category":"section"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"Here, we provide an implementation for Algorithm 4.4 of [1].","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"classify_maximal_lattice_free_polygons_m1p2_squares\nclassify_maximal_lattice_free_polygons_m1p2_trapezoids\nclassify_maximal_lattice_free_polygons_m1p2\nclassify_maximal_lattice_free_polygons","category":"page"},{"location":"classifications/#RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_squares","page":"Classifications","title":"RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_squares","text":"classify_maximal_lattice_free_polygons_m1p2_squares(k :: T) where {T <: Integer}\n\nReturn all k-maximal polygons with no interior lattice points that are contained in A cup mathbbR times -12 cup B where A is the square with vertices (01)(11)(12)(02) and B is the square with vertices (00)(0-1)(1-1)(10).\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_trapezoids","page":"Classifications","title":"RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_trapezoids","text":"classify_maximal_lattice_free_polygons_m1p2_trapezoids(k :: T) where {T <: Integer}\n\nReturn all k-maximal polygons with no interior lattice points that are contained in A cup mathbbR times -12 cup B where A is the trapezoid with vertices (-12)(01)(11)(12) and B is the trapezoid with vertices (00)(0-1)(2-1)(10), excluding the polygons from classify_maximal_lattice_free_polygons_m1p2_squares.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_maximal_lattice_free_polygons_m1p2","page":"Classifications","title":"RationalPolygons.classify_maximal_lattice_free_polygons_m1p2","text":"classify_maximal_lattice_free_polygons_m1p2(k :: T) where {T <: Integer}\n\nReturn all k-maximal polygons with no interior lattice points contained in mathbbR times -12. This is simply the union of classify_maximal_lattice_free_polygons_m1p2_squares and classify_maximal_lattice_free_polygons_m1p2_trapezoids.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_maximal_lattice_free_polygons","page":"Classifications","title":"RationalPolygons.classify_maximal_lattice_free_polygons","text":"classify_maximal_lattice_free_polygons(k :: T ; logging = false) where {T <: Integer}\n\nReturn all k-rational polygons with no interior lattice points.\n\nExample\n\nCompute the numbers of polygons for 1 ≤ k ≤ 6:\n\njulia> length.(classify_maximal_lattice_free_polygons.(1:6))\n6-element Vector{Int64}:\n   1\n   4\n  14\n  39\n 134\n 299\n\n\n\n\n\n","category":"function"},{"location":"classifications/#Rational-polygons-with-one-interior-lattice-point","page":"Classifications","title":"Rational polygons with one interior lattice point","text":"","category":"section"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"Here, we provide an implementation of Algorithm 5.4 of [1].","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"classify_maximal_polygons_genus_one_m1p1\nclassify_maximal_polygons_genus_one_m1p2\nclassify_maximal_polygons_genus_one_m2p2\nclassify_maximal_polygons_genus_one\nclassify_polygons_genus_one","category":"page"},{"location":"classifications/#RationalPolygons.classify_maximal_polygons_genus_one_m1p1","page":"Classifications","title":"RationalPolygons.classify_maximal_polygons_genus_one_m1p1","text":"classify_maximal_polygons_genus_one_m1p1(k :: T) where {T <: Integer}\n\nReturn all maximal k-rational polygons with exactly one interior lattice point that can be realized in mathbbR times -11. If primitive = true is passed, then only primitive polygons (i.e. ldp polygons) are returned.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_maximal_polygons_genus_one_m1p2","page":"Classifications","title":"RationalPolygons.classify_maximal_polygons_genus_one_m1p2","text":"classify_maximal_polygons_genus_one_m1p2(k :: T) where {T <: Integer}\n\nReturn all maximal k-rational polygons with exactly one interior lattice point that can be realized in mathbbR times -12. If primitive = true is passed, then only primitive polygons (i.e. ldp polygons) are returned.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_maximal_polygons_genus_one_m2p2","page":"Classifications","title":"RationalPolygons.classify_maximal_polygons_genus_one_m2p2","text":"classify_maximal_polygons_genus_one_m2p2(k :: T, q :: Int) where {T <: Integer}\n\nReturn all maximal k-rational polygons with exactly one interior lattice point that can be realized in mathbbR times -22 that have non-empty intersection with the q-th classification box, where 1 ≤ q ≤ 3. If primitive = true is passed, then only primitive polygons (i.e. ldp polygons) are returned.\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_maximal_polygons_genus_one","page":"Classifications","title":"RationalPolygons.classify_maximal_polygons_genus_one","text":"classify_maximal_polygons_genus_one(k :: T) where {T <: Integer}\n\nReturn all maximal k-rational polygons with exactly one interior lattice point. If primitive = true is passed, then only primitive polygons (i.e. ldp polygons) are returned.\n\nExample\n\nCompute the numbers of polygons for k  3.\n\njulia> length.(classify_maximal_polygons_genus_one.(1:3))\n4-element Vector{Int64}:\n   3\n  10\n  39\n\n\n\n\n\n","category":"function"},{"location":"classifications/#RationalPolygons.classify_polygons_genus_one","page":"Classifications","title":"RationalPolygons.classify_polygons_genus_one","text":"classify_polygons_genus_one(k :: T) where {T <: Integer}\n\nCompute all k-rational polygons with exactly one interior lattice point. The following keyword arguments are supported:\n\nprimitive :: Bool. If set to true, only primitive polygons (i.e. ldp polygons) are returned.\nlogging :: Bool. Controls whether to display logging messages showing the\n\ncurrent progress.\n\nExample\n\nReproduce the classifcation of all 5145 half-integral polygons with exactly one interior lattice point. It first computes all maximal polygons with classify_maximal_polygons_genus_one and then generates all their subpolygons.\n\njulia> classify_polygons_genus_one(2; logging=true);\n[ Info: Found 9 maximal polygons in QQ x [-1,1]. New: 9, total: 9\n[ Info: Found 2 maximal polygons in QQ x [-1,2]. New: 1, total: 10\n[ Info: Found 0 maximal polygons in QQ x [-2,2], box 1. New: 0, total: 10\n[ Info: Found 3 maximal polygons in QQ x [-2,2], box 2. New: 0, total: 10\n[ Info: Found 3 maximal polygons in QQ x [-2,2], box 3. New: 0, total: 10\n[ Info: [a = 36]. Polygons to peel: 2.\n[ Info: [a = 36]. Peeling complete. New polygons: 2. Running total: 12\n[ Info: [a = 35]. Polygons to peel: 2.\n[ Info: [a = 35]. Peeling complete. New polygons: 5. Running total: 17\n[ Info: [a = 34]. Polygons to peel: 5.\n[ Info: [a = 34]. Peeling complete. New polygons: 10. Running total: 27\n[ Info: [a = 33]. Polygons to peel: 9.\n[ Info: [a = 33]. Peeling complete. New polygons: 19. Running total: 46\n[ Info: [a = 32]. Polygons to peel: 23.\n[ Info: [a = 32]. Peeling complete. New polygons: 45. Running total: 91\n[ Info: [a = 31]. Polygons to peel: 31.\n[ Info: [a = 31]. Peeling complete. New polygons: 69. Running total: 160\n[ Info: [a = 30]. Polygons to peel: 60.\n[ Info: [a = 30]. Peeling complete. New polygons: 115. Running total: 275\n[ Info: [a = 29]. Polygons to peel: 84.\n[ Info: [a = 29]. Peeling complete. New polygons: 170. Running total: 445\n[ Info: [a = 28]. Polygons to peel: 137.\n[ Info: [a = 28]. Peeling complete. New polygons: 239. Running total: 684\n[ Info: [a = 27]. Polygons to peel: 171.\n[ Info: [a = 27]. Peeling complete. New polygons: 285. Running total: 969\n[ Info: [a = 26]. Polygons to peel: 240.\n[ Info: [a = 26]. Peeling complete. New polygons: 364. Running total: 1333\n[ Info: [a = 25]. Polygons to peel: 286.\n[ Info: [a = 25]. Peeling complete. New polygons: 440. Running total: 1773\n[ Info: [a = 24]. Polygons to peel: 356.\n[ Info: [a = 24]. Peeling complete. New polygons: 466. Running total: 2239\n[ Info: [a = 23]. Polygons to peel: 351.\n[ Info: [a = 23]. Peeling complete. New polygons: 433. Running total: 2672\n[ Info: [a = 22]. Polygons to peel: 396.\n[ Info: [a = 22]. Peeling complete. New polygons: 439. Running total: 3111\n[ Info: [a = 21]. Polygons to peel: 391.\n[ Info: [a = 21]. Peeling complete. New polygons: 394. Running total: 3505\n[ Info: [a = 20]. Polygons to peel: 390.\n[ Info: [a = 20]. Peeling complete. New polygons: 338. Running total: 3843\n[ Info: [a = 19]. Polygons to peel: 349.\n[ Info: [a = 19]. Peeling complete. New polygons: 269. Running total: 4112\n[ Info: [a = 18]. Polygons to peel: 357.\n[ Info: [a = 18]. Peeling complete. New polygons: 249. Running total: 4361\n[ Info: [a = 17]. Polygons to peel: 301.\n[ Info: [a = 17]. Peeling complete. New polygons: 215. Running total: 4576\n[ Info: [a = 16]. Polygons to peel: 292.\n[ Info: [a = 16]. Peeling complete. New polygons: 178. Running total: 4754\n[ Info: [a = 15]. Polygons to peel: 233.\n[ Info: [a = 15]. Peeling complete. New polygons: 121. Running total: 4875\n[ Info: [a = 14]. Polygons to peel: 191.\n[ Info: [a = 14]. Peeling complete. New polygons: 91. Running total: 4966\n[ Info: [a = 13]. Polygons to peel: 140.\n[ Info: [a = 13]. Peeling complete. New polygons: 71. Running total: 5037\n[ Info: [a = 12]. Polygons to peel: 121.\n[ Info: [a = 12]. Peeling complete. New polygons: 40. Running total: 5077\n[ Info: [a = 11]. Polygons to peel: 67.\n[ Info: [a = 11]. Peeling complete. New polygons: 21. Running total: 5098\n[ Info: [a = 10]. Polygons to peel: 56.\n[ Info: [a = 10]. Peeling complete. New polygons: 14. Running total: 5112\n[ Info: [a = 9]. Polygons to peel: 38.\n[ Info: [a = 9]. Peeling complete. New polygons: 13. Running total: 5125\n[ Info: [a = 8]. Polygons to peel: 31.\n[ Info: [a = 8]. Peeling complete. New polygons: 13. Running total: 5138\n[ Info: [a = 7]. Polygons to peel: 14.\n[ Info: [a = 7]. Peeling complete. New polygons: 3. Running total: 5141\n[ Info: [a = 6]. Polygons to peel: 13.\n[ Info: [a = 6]. Peeling complete. New polygons: 3. Running total: 5144\n[ Info: [a = 5]. Polygons to peel: 4.\n[ Info: [a = 5]. Peeling complete. New polygons: 1. Running total: 5145\n[ Info: [a = 4]. Polygons to peel: 3.\n[ Info: [a = 4]. Peeling complete. New polygons: 0. Running total: 5145\n[ Info: [a = 3]. Polygons to peel: 1.\n[ Info: [a = 3]. Peeling complete. New polygons: 0. Running total: 5145\n[ Info: [a = 2]. Polygons to peel: 0.\n[ Info: [a = 2]. Peeling complete. New polygons: 0. Running total: 5145\n[ Info: [a = 1]. Polygons to peel: 0.\n[ Info: [a = 1]. Peeling complete. New polygons: 0. Running total: 5145\n\n\n\n\n\n","category":"function"},{"location":"classifications/#Almost-k-hollow-LDP-polygons","page":"Classifications","title":"Almost k-hollow LDP polygons","text":"","category":"section"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"We can instruct classify_polygons_genus_one to only output k-rational polygons with primitive vertices. These are exactly the almost k-hollow LDP polygons and they correspond to 1k-log canonical toric del Pezzo surfaces. In particular, we can reproduce the classification of the 48032 almost 3-hollow LDP polygons (13-log canonical toric del Pezzo surfaces) from Theorem 4.11 of [7]. See also Table 6 of [1] for the classification up to k = 6.","category":"page"},{"location":"classifications/","page":"Classifications","title":"Classifications","text":"julia> Pss = [classify_polygons_genus_one(k; primitive=true) for k = 1 : 3];\n\njulia> numbers_of_polygons = length.(Pss)\n3-element Vector{Int64}:\n    16\n   505\n 48032\n\njulia> max_vertices = [maximum(number_of_vertices.(Pss[k])) for k = 1 : 3]\n3-element Vector{Int64}:\n  6\n  8\n 12\n\njulia> max_volumes = [k^2 * maximum(euclidian_area.(Pss[k])) for k = 1 : 3]\n3-element Vector{Rational{Int64}}:\n 9//2\n 17\n 47","category":"page"},{"location":"2dgeometry/#2D-Geometry","page":"2D Geometry","title":"2D Geometry","text":"","category":"section"},{"location":"2dgeometry/","page":"2D Geometry","title":"2D Geometry","text":"RationalPolygons.jl comes with its own library for two-dimensional geometry over the rational numbers, which is implented from scratch in pure Julia.","category":"page"},{"location":"2dgeometry/#Points","page":"2D Geometry","title":"Points","text":"","category":"section"},{"location":"2dgeometry/","page":"2D Geometry","title":"2D Geometry","text":"The basic types for points in RationalPolygons.jl are LatticePoint, RationalPoint and Point, which are aliases for static vectors of length two.","category":"page"},{"location":"2dgeometry/","page":"2D Geometry","title":"2D Geometry","text":"LatticePoint\nRationalPoint\nPoint\nis_k_rational(k :: T, p :: Point{T}) where {T <: Integer}\nis_integral\nrationality(p :: Point)\nmultiplicity\nis_primitive(p :: Point)\nnorm\ndistance\npseudo_angle","category":"page"},{"location":"2dgeometry/#RationalPolygons.LatticePoint","page":"2D Geometry","title":"RationalPolygons.LatticePoint","text":"LatticePoint{T <: Integer}\n\nA lattice point in two-dimensional space. This is an alias for SVector{2, T}.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.RationalPoint","page":"2D Geometry","title":"RationalPolygons.RationalPoint","text":"RationalPoint{T<:Integer}\n\nA rational point in two-dimensional space. This is an alias for SVector{2, Rational{T}}.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.Point","page":"2D Geometry","title":"RationalPolygons.Point","text":"Point{T<:Integer}\n\nThe union of LatticePoint and RationalPoint.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.is_k_rational-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{2, S} where S<:Union{Rational{T}, T}}} where T<:Integer","page":"2D Geometry","title":"RationalPolygons.is_k_rational","text":"is_k_rational(k :: T, p :: Point{T}) where {T <: Integer}\n\nChecks whether a point p is k-rational, i.e. its coordinates have denominator at most k.\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#RationalPolygons.is_integral","page":"2D Geometry","title":"RationalPolygons.is_integral","text":"is_integral(p :: Point{T}) where {T <: Integer}\n\nChecks whether a point p is integral.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.rationality-Tuple{StaticArraysCore.SVector{2, S} where {T<:Integer, S<:Union{Rational{T}, T}}}","page":"2D Geometry","title":"RationalPolygons.rationality","text":"rationality(p :: Point)\n\nThe smallest integer r such that r*p is integral.\n\nExample\n\njulia> rationality(RationalPoint(1//2,1//3))\n6\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#RationalPolygons.multiplicity","page":"2D Geometry","title":"RationalPolygons.multiplicity","text":"multiplicity(p :: Point)\n\nThe unique rational number x such that x*p is primitive and integral.\n\nExample\n\njulia> multiplicity(RationalPoint(4//3,2//3))\n3//2\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.is_primitive-Tuple{StaticArraysCore.SVector{2, S} where {T<:Integer, S<:Union{Rational{T}, T}}}","page":"2D Geometry","title":"RationalPolygons.is_primitive","text":"is_primitive(p :: Point)\n\nChecks whether a point is primitive, i.e. is integral and its coordinates are coprime.\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#RationalPolygons.norm","page":"2D Geometry","title":"RationalPolygons.norm","text":"norm(p :: Point{T})\n\nReturn the square of the euclidian norm of p.\n\nExample\n\njulia> norm(RationalPoint(4//3,2//3))\n20//9\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.distance","page":"2D Geometry","title":"RationalPolygons.distance","text":"distance(p :: Point{T}, q :: Point{T})\n\nReturn the square of the euclidian distance between p and q.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.pseudo_angle","page":"2D Geometry","title":"RationalPolygons.pseudo_angle","text":"pseudo_angle(p :: Point{T}) where {T <: Integer}\n\nA quick implementation of a pseudo_angle of two-dimensional vectors. It returns values in the half-open interval (-2,2].\n\nExample\n\njulia> pseudo_angle(LatticePoint(1,1))\n1//2\n\n\n\n\n\npseudo_angle(H :: AffineHalfplane{T}) where {T <: Integer}\n\nReturn the pseudo angle of the normal vector of H.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#Graham-scan","page":"2D Geometry","title":"Graham scan","text":"","category":"section"},{"location":"2dgeometry/","page":"2D Geometry","title":"2D Geometry","text":"graham_scan!\ngraham_scan","category":"page"},{"location":"2dgeometry/#RationalPolygons.graham_scan!","page":"2D Geometry","title":"RationalPolygons.graham_scan!","text":"graham_scan!(points :: Vector{<:Point{T}}) where {T <: Integer}\n\nPerform a graham scan on the given points, removing all points that are not vertices of their convex hull.\n\nExample\n\njulia> points = LatticePoint{Int}[(0,0),(1,0),(1,1),(0,1),(-1,1),(0,-1),(-1,-1),(0,-1)];\n\njulia> graham_scan!(points)\n5-element Vector{StaticArraysCore.SVector{2, Int64}}:\n [-1, -1]\n [0, -1]\n [1, 0]\n [1, 1]\n [-1, 1]\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.graham_scan","page":"2D Geometry","title":"RationalPolygons.graham_scan","text":"graham_scan(points :: Vector{<:Point{T}}) where {T <: Integer}\n\nA non-modifying version of graham_scan!.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#Lines","page":"2D Geometry","title":"Lines","text":"","category":"section"},{"location":"2dgeometry/","page":"2D Geometry","title":"2D Geometry","text":"Line\nbase_point\ndirection_vector\nline_through_points\nhorizontal_line\nvertical_line\nBase.in(x :: Point{T}, L :: Line{T}) where {T <: Integer}\nnormal_vector(L :: Line{T}) where {T <: Integer}\nIntersectionBehaviour\nIntersectInPoint\nNoIntersection\nLinesAreEqual\nintersection_behaviour\nintersection_point","category":"page"},{"location":"2dgeometry/#RationalPolygons.Line","page":"2D Geometry","title":"RationalPolygons.Line","text":"Line{T <: Integer}\n\nA line in 2-dimensional rational space. It has two fields: base_point :: RationalPoint{T} and direction_vector :: RationalPoint{T}.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.base_point","page":"2D Geometry","title":"RationalPolygons.base_point","text":"base_point(L :: Line{T}) where {T <: Integer}\n\nReturn a point on the line L.\n\n\n\n\n\nbase_point(H :: AffineHalfplane{T}) where {T <: Integer}\n\nReturn a point on the line associated to H.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.direction_vector","page":"2D Geometry","title":"RationalPolygons.direction_vector","text":"direction_vector(L :: Line{T}) where {T <: Integer}\n\nReturn the direction vector of L.\n\n\n\n\n\ndirection_vector(H :: AffineHalfplane{T}) where {T <: Integer}\n\nReturn the direction vector of the line associated to H.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.line_through_points","page":"2D Geometry","title":"RationalPolygons.line_through_points","text":"line_through_points(A :: Point{T}, B :: Point{T}) where {T <: Integer}\n\nReturn the line going through the points A and B.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.horizontal_line","page":"2D Geometry","title":"RationalPolygons.horizontal_line","text":"horizontal_line(y :: Union{T, Rational{T}}) where {T <: Integer}\n\nReturn the horizontal line at y.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.vertical_line","page":"2D Geometry","title":"RationalPolygons.vertical_line","text":"vertical_line(x :: Union{T, Rational{T}}) where {T <: Integer}\n\nReturn the vertical line at x.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#Base.in-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, S} where S<:Union{Rational{T}, T}, Line{T}}} where T<:Integer","page":"2D Geometry","title":"Base.in","text":"Base.in(x :: Point{T}, L :: Line{T}) where {T <: Integer}\n\nCheck whether a point x lies on a line L.\n\nExample\n\njulia> RationalPoint(3//2,1) ∈ line_through_points(Point(1,0),Point(2,2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#RationalPolygons.normal_vector-Union{Tuple{Line{T}}, Tuple{T}} where T<:Integer","page":"2D Geometry","title":"RationalPolygons.normal_vector","text":"normal_vector(L :: Line{T}) where {T <: Integer}\n\nReturn a primitive vector orthogonal to the direction vector of L.\n\nExample\n\njulia> normal_vector(line_through_points(Point(1,0),Point(2,2)))\n2-element StaticArraysCore.SVector{2, Int64} with indices SOneTo(2):\n -2\n  1\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#RationalPolygons.IntersectionBehaviour","page":"2D Geometry","title":"RationalPolygons.IntersectionBehaviour","text":"IntersectionBehaviour{T <: Integer}\n\nAn abstract supertype for possible intersection behaviours of two lines. There are the three subtypes IntersectInPoint, NoIntersection and LinesAreEqual.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.IntersectInPoint","page":"2D Geometry","title":"RationalPolygons.IntersectInPoint","text":"IntersectInPoint{T <: Integer}\n\nThe intersection behaviour of two lines intersecting in a unique point. This struct has a single field p, which is the intersection point.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.NoIntersection","page":"2D Geometry","title":"RationalPolygons.NoIntersection","text":"NoIntersection{T <: Integer}\n\nThe intersection behaviour of parallel lines.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.LinesAreEqual","page":"2D Geometry","title":"RationalPolygons.LinesAreEqual","text":"LinesAreEqual{T <: Integer}\n\nThe intersection behaviour of two equal lines.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.intersection_behaviour","page":"2D Geometry","title":"RationalPolygons.intersection_behaviour","text":"intersection_behaviour(L1 :: Line{T}, L2 :: Line{T}) where {T <: Integer}\n\nGiven two lines in 2D rational space, return the intersection behaviour of the two lines: Possible values are LinesAreEqual(), NoIntersection() and IntersectInPoint(p) where p is the unique intersection point.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.intersection_point","page":"2D Geometry","title":"RationalPolygons.intersection_point","text":"intersection_point(L1 :: Line{T}, L2 :: Line{T}) where {T <: RationalUnion}\n\nReturn the intersection point of two lines in 2D rational space. Throws an error if the lines do not intersect uniquely.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#Affine-halfplanes","page":"2D Geometry","title":"Affine halfplanes","text":"","category":"section"},{"location":"2dgeometry/","page":"2D Geometry","title":"2D Geometry","text":"AffineHalfplane\naffine_halfplane\nnormal_vector(H :: AffineHalfplane{T}) where {T <: Integer}\ntranslation\nBase.in(x :: Point{T}, H :: AffineHalfplane{T}) where {T <: Integer}\ncontains_in_interior(x :: Point{T}, H :: AffineHalfplane{T}) where {T <: Integer}\nBase.issubset(H1 :: AffineHalfplane{T}, H2 :: AffineHalfplane{T}) where {T <: Integer}\nline(H :: AffineHalfplane{T}) where {T <: Integer}","category":"page"},{"location":"2dgeometry/#RationalPolygons.AffineHalfplane","page":"2D Geometry","title":"RationalPolygons.AffineHalfplane","text":"AffineHalfplane{T <: Integer}\n\nAn affine halfplane in two-dimensional rational space. It has two fields normal_vector :: RationalPoint{T} and translation :: Rational{T}.\n\n\n\n\n\n","category":"type"},{"location":"2dgeometry/#RationalPolygons.affine_halfplane","page":"2D Geometry","title":"RationalPolygons.affine_halfplane","text":"affine_halfplane(nv :: Point{T}, b :: Union{T, Rational{T}}) where {T <: Integer}\n\nReturn the affine halfplane given by the equation nv[1] * x[1] + nv[2] * x[2] ≥ b.\n\nExample\n\njulia> affine_halfplane(Point(-2,1),1)\nAffine halfplane given by -2//1 x + 1//1 y ≥ 1//1\n\n\n\n\n\naffine_halfplane(L :: Line{T}) where {T <: Integer}\n\nReturn the affine halfplane associated to a line in 2D space. The halfplane is understood to consist of those points to the left of the line L, looking in the direction given by direction_vector(L).\n\n\n\n\n\naffine_halfplane(p :: Point{T}, q :: Point{T}) where {T <: Integer}\n\nReturn the affine halfplane associated to the line going through the points p and q.\n\n\n\n\n\naffine_halfplane(P :: RationalPolygon, i :: Int)\n\nReturn the i-th describing halfplane of P.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#RationalPolygons.normal_vector-Union{Tuple{AffineHalfplane{T}}, Tuple{T}} where T<:Integer","page":"2D Geometry","title":"RationalPolygons.normal_vector","text":"normal_vector(H :: AffineHalfplane{T}) where {T <: Integer}\n\nReturn the normal vector of the H.\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#RationalPolygons.translation","page":"2D Geometry","title":"RationalPolygons.translation","text":"translation(H :: AffineHalfplane{T}) where {T <: Integer}\n\nReturn the affine translation of H.\n\n\n\n\n\n","category":"function"},{"location":"2dgeometry/#Base.in-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, S} where S<:Union{Rational{T}, T}, AffineHalfplane{T}}} where T<:Integer","page":"2D Geometry","title":"Base.in","text":"Base.in(x :: Point{T}, H :: AffineHalfplane{T}) where {T <: Integer}\n\nCheck whether a point x lies in the halfplane H.\n\nExample\n\njulia> Point(0,1) ∈ affine_halfplane(Point(-2,1),1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#RationalPolygons.contains_in_interior-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, S} where S<:Union{Rational{T}, T}, AffineHalfplane{T}}} where T<:Integer","page":"2D Geometry","title":"RationalPolygons.contains_in_interior","text":"contains_in_interior(x :: Point{T}, H :: AffineHalfplane{T}) where {T <: Integer}\n\nCheck whether a point x lies in the interior of H.\n\nExample\n\njulia> contains_in_interior(Point(0,1), affine_halfplane(Point(-2,1),1))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#Base.issubset-Union{Tuple{T}, Tuple{AffineHalfplane{T}, AffineHalfplane{T}}} where T<:Integer","page":"2D Geometry","title":"Base.issubset","text":"Base.issubset(H1 :: AffineHalfplane{T}, H2 :: AffineHalfplane{T}) where {T <: Integer}\n\nCheck whether H1 is a subset of H2.\n\n\n\n\n\n","category":"method"},{"location":"2dgeometry/#RationalPolygons.line-Union{Tuple{AffineHalfplane{T}}, Tuple{T}} where T<:Integer","page":"2D Geometry","title":"RationalPolygons.line","text":"line(H :: AffineHalfplane{T}) where {T <: Integer}\n\nReturn the line associated to H.\n\n\n\n\n\n","category":"method"},{"location":"#RationalPolygons.jl","page":"Home","title":"RationalPolygons.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RationalPolygons.jl is a pure Julia package for computations with rational convex polygons. It implements","category":"page"},{"location":"","page":"Home","title":"Home","text":"counting lattice points, Ehrhart Theory, normal forms, automorphism groups, computation of subpolygons,\nvarious classification algorithms for integral and rational polygons.","category":"page"},{"location":"","page":"Home","title":"Home","text":"I have written RationalPolygons.jl in the span of about six months while working on a joint project with Martin Bohnert [1]. Its main purpose is to provide reference implementations of the classification algorithms developed in our paper. However, it also implements many more basic algorithms for computations with rational polygons that I believe might be useful in other projects, hence I have documented them here. RationalPolygons.jl does not make use of any external computer algebra system but implements all necessary algorithms, including two-dimensional euclidian geometry, from scratch in pure Julia. This allows for quite good performance, with computations involving billions of polygons being feasable on a personal computer.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using RationalPolygons\nP = convex_hull(LatticePoint{Int}[(1,0),(0,1),(-1,1),(-1,0),(0,-1),(1,-1)])\nplot_polygon(P)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"number_of_interior_lattice_points(P)\nnumber_of_boundary_lattice_points(P)\neuclidian_area(P)\nehrhart_quasipolynomial(P)\naffine_automorphism_group(P)\nis_fano(P)\ndual(P)\nare_affine_equivalent(P, dual(P))\ngorenstein_index(P)","category":"page"},{"location":"","page":"Home","title":"Home","text":"M. Bohnert and J. Springer. Classifying rational polygons with small denominator and few interior lattice points (2024), arXiv:2410.17244 [math.CO].\n\n\n\nM. Bohnert. Area bounds for planar convex bodies containing a fixed number of interior integral points (2023), arXiv:2305.11485 [math.MG].\n\n\n\nD. A. Cox, J. B. Little and H. K. Schenck. Toric varieties. Vol. 124 of Graduate Studies in Mathematics (American Mathematical Society, Providence, RI, 2011); p. xxiv+841.\n\n\n\nR. J. Koelman. The number of moduli of families of curves on toric surfaces. Ph.D. Thesis, University of Nijmegen (1991).\n\n\n\nW. Castryck. Moving out the edges of a lattice polygon. Discrete Comput. Geom. 47, 496–518 (2012).\n\n\n\nG. Brown and A. M. Kasprzyk. Small polygons and toric codes. J. Symbolic Comput. 51, 55–62 (2013).\n\n\n\nD. Haettig, J. Hausen and J. Springer. Classifying log del Pezzo surfaces with torus action (2023), arXiv:2302.03095 [math.AG].\n\n\n\n","category":"page"}]
}
