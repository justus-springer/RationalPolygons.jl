<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Classifications · RationalPolygons</title><meta name="title" content="Classifications · RationalPolygons"/><meta property="og:title" content="Classifications · RationalPolygons"/><meta property="twitter:title" content="Classifications · RationalPolygons"/><meta name="description" content="Documentation for RationalPolygons."/><meta property="og:description" content="Documentation for RationalPolygons."/><meta property="twitter:description" content="Documentation for RationalPolygons."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RationalPolygons</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../2dgeometry/">2D Geometry</a></li><li><a class="tocitem" href="../polygons/">Rational Polygons</a></li><li><a class="tocitem" href="../subpolygons/">Subpolygons</a></li><li class="is-active"><a class="tocitem" href>Classifications</a><ul class="internal"><li><a class="tocitem" href="#Lattice-polygons-by-number-of-lattice-points"><span>Lattice polygons by number of lattice points</span></a></li><li><a class="tocitem" href="#Lattice-polygons-by-number-of-interior-lattice-points"><span>Lattice polygons by number of interior lattice points</span></a></li><li><a class="tocitem" href="#Lattice-polygons-contained-in-a-square"><span>Lattice polygons contained in a square</span></a></li><li><a class="tocitem" href="#Maximal-rational-polygons-contained-in-\\mathbb{R}\\times[-1,1]"><span>Maximal rational polygons contained in <span>$\mathbb{R}\times[-1,1]$</span></span></a></li><li><a class="tocitem" href="#Maximal-rational-polygons-with-no-interior-lattice-points"><span>Maximal rational polygons with no interior lattice points</span></a></li><li><a class="tocitem" href="#Rational-polygons-with-one-interior-lattice-point"><span>Rational polygons with one interior lattice point</span></a></li><li><a class="tocitem" href="#Almost-k-hollow-LDP-polygons"><span>Almost <span>$k$</span>-hollow LDP polygons</span></a></li></ul></li><li><a class="tocitem" href="../docs_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Classifications</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Classifications</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/justus-springer/RationalPolygons.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/justus-springer/RationalPolygons.jl/blob/main/docs/src/classifications.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Classifications"><a class="docs-heading-anchor" href="#Classifications">Classifications</a><a id="Classifications-1"></a><a class="docs-heading-anchor-permalink" href="#Classifications" title="Permalink"></a></h1><p>RationalPolygons.jl implements the following classification algorithms:</p><ul><li><a href="#Lattice-polygons-by-number-of-lattice-points">Lattice polygons by number of lattice points</a> from R.J. Koelman [<a href="../#Koe91">4</a>],</li><li><a href="#Lattice-polygons-by-number-of-interior-lattice-points">Lattice polygons by number of interior lattice points</a> from Castryck [<a href="../#Cas12">5</a>],</li><li><a href="#Lattice-polygons-contained-in-a-square">Lattice polygons contained in a square</a> from Brown and Kasprzyk [<a href="../#BK13">6</a>],</li></ul><p>Moreover, the classifications from [<a href="../#BS24">1</a>] are implemented:</p><ul><li><a href="#Maximal-rational-polygons-contained-in-\\mathbb{R}\\times[-1,1]">Maximal rational polygons contained in <span>$\mathbb{R}\times[-1,1]$</span></a>,</li><li><a href="#Maximal-rational-polygons-with-no-interior-lattice-points">Maximal rational polygons with no interior lattice points</a>,</li><li><a href="#Rational-polygons-with-one-interior-lattice-point">Rational polygons with one interior lattice point</a>,</li><li><a href="#Almost-k-hollow-LDP-polygons">Almost <span>$k$</span>-hollow LDP polygons</a>.</li></ul><h2 id="Lattice-polygons-by-number-of-lattice-points"><a class="docs-heading-anchor" href="#Lattice-polygons-by-number-of-lattice-points">Lattice polygons by number of lattice points</a><a id="Lattice-polygons-by-number-of-lattice-points-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-polygons-by-number-of-lattice-points" title="Permalink"></a></h2><p>In his PhD thesis, R.J. Koelman describes an algorithm to classify lattice polygons with a given number of lattice points and ran it up to 42 lattice points, Table 4.4.3 of [<a href="../#Koe91">4</a>]. We have implemented his algorithm here, which sucessfully reproduces Koelman&#39;s original numbers, see also <a href="https://oeis.org/A371917">A371917</a> on OEIS</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.height_one_points" href="#RationalPolygons.height_one_points"><code>RationalPolygons.height_one_points</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">height_one_points(P :: RationalPolygon)</code></pre><p>Given a lattice polygon <code>P</code>, return all lattice points that have lattice height one with respect to some edge of <code>P</code>. Equivalently, return the set of boundary lattice points of <code>move_out_edges(P)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.single_point_extensions" href="#RationalPolygons.single_point_extensions"><code>RationalPolygons.single_point_extensions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">single_point_extensions(Ps :: Vector{&lt;:RationalPolygon{T}}) where {T &lt;: Integer}</code></pre><p>Return all lattice polygons that can be obtained by adding a single height one point to a polygon of <code>Ps</code>, up to affine equivalence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.KoelmanStorage" href="#RationalPolygons.KoelmanStorage"><code>RationalPolygons.KoelmanStorage</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type KoelmanStorage{T &lt;: Integer} end</code></pre><p>Abstract supertype of <code>InMemoryKoelmanStorage</code> and <code>HDFKoelmanStorage</code>. Both implement <code>classify_next_number_of_lattice_points</code>, which performs a single step in Koelman&#39;s classification of lattice polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.InMemoryKoelmanStorage" href="#RationalPolygons.InMemoryKoelmanStorage"><code>RationalPolygons.InMemoryKoelmanStorage</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct InMemoryKoelmanStorage{T &lt;: Integer} &lt;: KoelmanStorage{T}</code></pre><p>A struct holding classification results of Koelman&#39;s classification of lattice polygons by number of lattice points. It has two fields <code>polygons :: Vector{Vector{RationalPolygon{T}}</code> and <code>total_count :: Int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L98-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.HDFKoelmanStoragePreferences" href="#RationalPolygons.HDFKoelmanStoragePreferences"><code>RationalPolygons.HDFKoelmanStoragePreferences</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HDFKoelmanStoragePreferences{T &lt;: Integer}</code></pre><p>A struct holding preferences for Koelman&#39;s classification using the HDF5 file format. It has four fields:</p><ul><li><code>swmr :: Bool</code>: Whether to use single-reader-multiple-writer mode for HDF5.   Defaults to <code>true</code>.</li><li><code>maximum_number_of_vertices :: Int</code>: An upper bound for the maximal number of   vertices to be expected in the classification. This has to be set since every   HDF5 file generated will have a dataset &quot;numbers_of_polygons&quot; storing the   number of polygons for each number of vertices and the size of this dataset   needs to be set beforehand. Defaults to <code>100</code>, which should be more than enough for any   feasable computation.</li><li><code>block_size :: Int</code>: How many polygons should be read into memory at once   during the extension process. Defaults to <code>10^6</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L163-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.HDFKoelmanStorage" href="#RationalPolygons.HDFKoelmanStorage"><code>RationalPolygons.HDFKoelmanStorage</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct HDFKoelmanStorage{T &lt;: Integer} &lt;: KoelmanStorage{T}</code></pre><p>A struct for managing classification results of Koelman&#39;s classification of lattice polygons using the HDF5 file format. It has the following fields:</p><ul><li><code>preferences :: HDFKoelmanStoragePreferences{T}</code></li><li><code>directory_path :: String</code>: The directory where the HDF5 files will be generated.</li><li><code>last_completed_number_of_lattice_points :: Int</code>: The last completed step of the classification. Initially, this will be <code>3</code>.</li><li><code>total_count :: Int</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L194-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_next_number_of_lattice_points" href="#RationalPolygons.classify_next_number_of_lattice_points"><code>RationalPolygons.classify_next_number_of_lattice_points</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_next_number_of_lattice_points(st :: InMemoryKoelmanStorage{T}) where {T &lt;: Integer}</code></pre><p>Perform a single step in Koelman&#39;s classification of lattice polygons using in-memory storage.</p><p><strong>Example</strong></p><p>Perform a single step of Koelmans classification using <code>Int64</code>. The result tells us that there are three lattice polygons with exactly four lattice points.</p><pre><code class="language-julia-repl hljs">julia&gt; st = InMemoryKoelmanStorage{Int64}();

julia&gt; classify_next_number_of_lattice_points(st)
3

julia&gt; st.polygons[4]
3-element Vector{RationalPolygon{Int64}}:
 Rational polygon of rationality 1 with 3 vertices.
 Rational polygon of rationality 1 with 4 vertices.
 Rational polygon of rationality 1 with 3 vertices.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L121-L147">source</a></section><section><div><pre><code class="language-julia hljs">classify_next_number_of_lattice_points(st :: HDFKoelmanStorage{T}; logging :: Bool = false) where {T &lt;: Integer}</code></pre><p>Perform a single step in Koelman&#39;s classification of lattice polygons using on-disk storage with HDF5.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L241-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_polygons_by_number_of_lattice_points" href="#RationalPolygons.classify_polygons_by_number_of_lattice_points"><code>RationalPolygons.classify_polygons_by_number_of_lattice_points</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_polygons_by_number_of_lattice_points(st :: KoelmanStorage{T}, max_number_of_lattice_points :: Int; logging :: Bool = false) where {T &lt;: Integer}</code></pre><p>Run Koelman&#39;s classification of lattice polygons by number of lattice points, up to <code>max_number_of_lattice_points</code>. The classification is multithreaded, so make sure julia has access to a good number of threads for maximum performance (i.e. <code>Threads.nthreads()</code> is greater than one).</p><p><strong>Example</strong></p><p>Reproduce Koelman&#39;s original classification in memory, see Table 4.4.3 of [<a href="../#Koe91">4</a>] or A371917 on OEIS. This should not take longer than a few minutes on modern hardware.</p><pre><code class="language-julia hljs">julia&gt; st = InMemoryKoelmanStorage{Int}();

julia&gt; classify_polygons_by_number_of_lattice_points(st, 42; logging=true);
[ Info: [l = 4]. New polygons: 3. Total: 4
[ Info: [l = 5]. New polygons: 6. Total: 10
[ Info: [l = 6]. New polygons: 13. Total: 23
[ Info: [l = 7]. New polygons: 21. Total: 44
[ Info: [l = 8]. New polygons: 41. Total: 85
[ Info: [l = 9]. New polygons: 67. Total: 152
[ Info: [l = 10]. New polygons: 111. Total: 263
[ Info: [l = 11]. New polygons: 175. Total: 438
[ Info: [l = 12]. New polygons: 286. Total: 724
[ Info: [l = 13]. New polygons: 419. Total: 1143
[ Info: [l = 14]. New polygons: 643. Total: 1786
[ Info: [l = 15]. New polygons: 938. Total: 2724
[ Info: [l = 16]. New polygons: 1370. Total: 4094
[ Info: [l = 17]. New polygons: 1939. Total: 6033
[ Info: [l = 18]. New polygons: 2779. Total: 8812
[ Info: [l = 19]. New polygons: 3819. Total: 12631
[ Info: [l = 20]. New polygons: 5293. Total: 17924
[ Info: [l = 21]. New polygons: 7191. Total: 25115
[ Info: [l = 22]. New polygons: 9752. Total: 34867
[ Info: [l = 23]. New polygons: 12991. Total: 47858
[ Info: [l = 24]. New polygons: 17321. Total: 65179
[ Info: [l = 25]. New polygons: 22641. Total: 87820
[ Info: [l = 26]. New polygons: 29687. Total: 117507
[ Info: [l = 27]. New polygons: 38533. Total: 156040
[ Info: [l = 28]. New polygons: 49796. Total: 205836
[ Info: [l = 29]. New polygons: 63621. Total: 269457
[ Info: [l = 30]. New polygons: 81300. Total: 350757
[ Info: [l = 31]. New polygons: 102807. Total: 453564
[ Info: [l = 32]. New polygons: 129787. Total: 583351
[ Info: [l = 33]. New polygons: 162833. Total: 746184
[ Info: [l = 34]. New polygons: 203642. Total: 949826
[ Info: [l = 35]. New polygons: 252898. Total: 1202724
[ Info: [l = 36]. New polygons: 313666. Total: 1516390
[ Info: [l = 37]. New polygons: 386601. Total: 1902991
[ Info: [l = 38]. New polygons: 475540. Total: 2378531
[ Info: [l = 39]. New polygons: 582216. Total: 2960747
[ Info: [l = 40]. New polygons: 710688. Total: 3671435
[ Info: [l = 41]. New polygons: 863552. Total: 4534987
[ Info: [l = 42]. New polygons: 1048176. Total: 5583163</code></pre><p><strong>Example</strong></p><p>Reproduce Koelman&#39;s classification and storing the output to HDF5 files.</p><pre><code class="language-julia hljs">julia&gt; st = HDFKoelmanStorage{Int}(&quot;/tmp&quot;);

julia&gt; classify_polygons_by_number_of_lattice_points(st, 42);</code></pre><p>The result will be HDF5 files named &quot;l1.h5, l2.h5, ...&quot;, each containing one dataset of polygons for fixed number of vertices as well as a dataset &quot;numbers_of_polygons&quot; holding their numbers.</p><pre><code class="language-julia hljs">julia&gt; using HDF5

julia&gt; f = h5open(&quot;/tmp/test/l42.h5&quot;, &quot;r&quot;)
🗂️ HDF5.File: (read-only) /tmp/test/l42.h5
├─ 🔢 n10
├─ 🔢 n11
├─ 🔢 n12
├─ 🔢 n3
├─ 🔢 n4
├─ 🔢 n5
├─ 🔢 n6
├─ 🔢 n7
├─ 🔢 n8
├─ 🔢 n9
└─ 🔢 numbers_of_polygons

julia&gt; A = read_dataset(f, &quot;numbers_of_polygons&quot;);

julia&gt; sum(A) # the number of lattice polygons with 42 lattice points
1048176

julia&gt; Ps = read_polygon_dataset(1, f, &quot;n5&quot;); # Read in all pentagons with 42 lattice points.

julia&gt; all(P -&gt; number_of_lattice_points(P) == 42, Ps)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/koelman.jl#L304-L405">source</a></section></article><h2 id="Lattice-polygons-by-number-of-interior-lattice-points"><a class="docs-heading-anchor" href="#Lattice-polygons-by-number-of-interior-lattice-points">Lattice polygons by number of interior lattice points</a><a id="Lattice-polygons-by-number-of-interior-lattice-points-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-polygons-by-number-of-interior-lattice-points" title="Permalink"></a></h2><p>In [<a href="../#Cas12">5</a>], Castryck describes an algorithm for the classification of lattice polygons by their number of interior lattice points and ran it up to 30 interior lattice points. Our implementation here successfully reproduces his numbers from Table 1 of [<a href="../#Cas12">5</a>], see also <a href="https://oeis.org/A322343">A322343</a> on OEIS.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_lattice_polygons_with_collinear_interior_points" href="#RationalPolygons.classify_maximal_lattice_polygons_with_collinear_interior_points"><code>RationalPolygons.classify_maximal_lattice_polygons_with_collinear_interior_points</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_lattice_polygons_with_collinear_interior_points(i :: Int, T :: Type{&lt;:Integer} = Int)</code></pre><p>Return all maximal lattice polygons with <code>i</code> collinear interior lattice points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_lattice_polygons_with_two_dimensional_empty_fine_interior" href="#RationalPolygons.classify_maximal_lattice_polygons_with_two_dimensional_empty_fine_interior"><code>RationalPolygons.classify_maximal_lattice_polygons_with_two_dimensional_empty_fine_interior</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_lattice_polygons_with_two_dimensional_empty_fine_interior(i :: Int, T :: Type{&lt;:Integer} = Int)</code></pre><p>Return all maximal lattice polygons with <code>i</code> interior lattice points, where the convex hull of these points is a two-dimensional lattice polygon without interior lattice points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.CastryckStorage" href="#RationalPolygons.CastryckStorage"><code>RationalPolygons.CastryckStorage</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type CastryckStorage{T &lt;: Integer} end</code></pre><p>Abstract supertype of <code>InMemoryCastryckStorage</code> and <code>HDFCastryckStorage</code>. Both implement <code>classify_next_genus</code>, which performs a single step in Castryck&#39;s classification of lattice polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.InMemoryCastryckStorage" href="#RationalPolygons.InMemoryCastryckStorage"><code>RationalPolygons.InMemoryCastryckStorage</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct InMemoryCastryckStorage{T &lt;: Integer} &lt;: CastryckStorage{T}</code></pre><p>A struct holding classification results of Castryck&#39;s classification of lattice polygons by number of interior lattice points (i.e. their genus). It has the following fields:</p><ul><li><code>maximum_genus :: Int</code>: An upper bound for the maximum genus that the  classification should run to. Defaults to <code>100</code>.</li><li><code>maximal_polygons :: Vector{Vector{RationalPolygon{T}}}</code>,</li><li><code>all_polygons :: Vector{Vector{RationalPolygon{T}}}</code>,</li><li><code>total_count :: Int</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.HDFCastryckStoragePreferences" href="#RationalPolygons.HDFCastryckStoragePreferences"><code>RationalPolygons.HDFCastryckStoragePreferences</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HDFCastryckStoragePreferences{T &lt;: Integer}</code></pre><p>A struct holding preferences for Castryck&#39;s classification using the HDF5 file format. It has four fields:</p><ul><li><code>swmr :: Bool</code>: Whether to use single-reader-multiple-writer mode for HDF5.   Defaults to <code>true</code>.</li><li><code>maximum_genus :: Int</code>: An upper bound for the maximal number of interior   lattice points to which the classification should be run. Defaults to <code>100</code>.</li><li><code>maximum_number_of_vertices :: Int</code>: An upper bound for the maximal number of   vertices to be expected in the classification. This has to be set since every   HDF5 file generated will have a dataset &quot;numbers_of_polygons&quot; storing the   number of polygons for each number of vertices and the size of this dataset   needs to be set beforehand. Defaults to <code>100</code>, which should be more than enough for any   feasable computation.</li><li><code>block_size :: Int</code>: How many polygons should be read into memory at once   during the computation of subpolygons and the moving-out process. Defaults to   <code>10^6</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L185-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.HDFCastryckStorage" href="#RationalPolygons.HDFCastryckStorage"><code>RationalPolygons.HDFCastryckStorage</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct HDFCastryckStorage{T &lt;: Integer} &lt;: CastryckStorage{T}</code></pre><p>A struct for managing classification results of Castryck&#39;s classification of lattice polygons using the HDF5 file format. It has the following fields:</p><ul><li><code>preferences :: HDFCastryckStoragePreferences{T}</code></li><li><code>directory_path :: String</code>: The directory where the HDF5 files will be generated.</li><li><code>last_completed_genus :: Int</code>: The last completed step of the classification. Initially, this will be <code>0</code>.</li><li><code>total_count :: Int</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L222-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_next_genus" href="#RationalPolygons.classify_next_genus"><code>RationalPolygons.classify_next_genus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_next_genus(st :: InMemoryCastryckStorage{T}; logging :: Bool = false) where {T &lt;: Integer}</code></pre><p>Perform a single step in Castryck&#39;s classification of lattice polygons by number of interior lattice points, using in-memory storage. Returns a tuple where the first entry is the number of lattice polygons obtained and the second number is the number of maximal lattice polygons.</p><p><strong>Example</strong></p><p>Perform two steps in Castryck&#39;s classification. The result tells us that there are 45 lattice polygons with exactly two interior lattice points, four of which are maximal.</p><pre><code class="language-julia-repl hljs">julia&gt; st = InMemoryCastryckStorage{Int}();

julia&gt; classify_next_genus(st)
(16, 3)

julia&gt; classify_next_genus(st)
(45, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L107-L132">source</a></section><section><div><pre><code class="language-julia hljs">classify_next_genus(st :: HDFCastryckStorage{T}; logging :: Bool = false) where {T &lt;: Integer}</code></pre><p>Perform a single step in Castryck&#39;s classification of lattice polygons using on-disk storage with HDF5.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L284-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_lattice_polygons_by_genus" href="#RationalPolygons.classify_lattice_polygons_by_genus"><code>RationalPolygons.classify_lattice_polygons_by_genus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_lattice_polygons_by_genus(st :: CastryckStorage{T}, max_genus :: Int; logging :: Bool = false) where {T &lt;: Integer}</code></pre><p>Run Castryck&#39;s classification of lattice polygons by number of interior lattice points, up to <code>max_genus</code>. The classification is multithreaded, so make sure julia has access to a good number of threads for maximum performance (i.e. <code>Threads.nthreads()</code> is greater than one).</p><p><strong>Example</strong></p><p>Reproduce Castryck&#39;s classification in memory, see Table 1 of [<a href="../#Cas12">5</a>] or A322343 on OEIS. This should not take longer than a few minutes on modern hardware.</p><pre><code class="language-julia hljs">julia&gt; st = InMemoryCastryckStorage{Int}();

julia&gt; classify_lattice_polygons_by_genus(st, 30; logging=true)
[ Info: [i = 1]. Got 3 maximal polygons.
[ Info: [i = 1]. Subpolygons complete. Num of polygons: 16
[ Info: [i = 1]. Moving out complete. New maximal polygons: 16
[ Info: [i = 2]. Got 4 maximal polygons.
[ Info: [i = 2]. Subpolygons complete. Num of polygons: 45
[ Info: [i = 2]. Moving out complete. New maximal polygons: 22
[ Info: [i = 3]. Got 6 maximal polygons.
[ Info: [i = 3]. Subpolygons complete. Num of polygons: 120
[ Info: [i = 3]. Moving out complete. New maximal polygons: 63
[ Info: [i = 4]. Got 9 maximal polygons.
[ Info: [i = 4]. Subpolygons complete. Num of polygons: 211
[ Info: [i = 4]. Moving out complete. New maximal polygons: 78
[ Info: [i = 5]. Got 11 maximal polygons.
[ Info: [i = 5]. Subpolygons complete. Num of polygons: 403
[ Info: [i = 5]. Moving out complete. New maximal polygons: 122
[ Info: [i = 6]. Got 13 maximal polygons.
[ Info: [i = 6]. Subpolygons complete. Num of polygons: 714
[ Info: [i = 6]. Moving out complete. New maximal polygons: 192
[ Info: [i = 7]. Got 16 maximal polygons.
[ Info: [i = 7]. Subpolygons complete. Num of polygons: 1023
[ Info: [i = 7]. Moving out complete. New maximal polygons: 239
[ Info: [i = 8]. Got 21 maximal polygons.
[ Info: [i = 8]. Subpolygons complete. Num of polygons: 1830
[ Info: [i = 8]. Moving out complete. New maximal polygons: 316
[ Info: [i = 9]. Got 27 maximal polygons.
[ Info: [i = 9]. Subpolygons complete. Num of polygons: 2700
[ Info: [i = 9]. Moving out complete. New maximal polygons: 508
[ Info: [i = 10]. Got 33 maximal polygons.
[ Info: [i = 10]. Subpolygons complete. Num of polygons: 3659
[ Info: [i = 10]. Moving out complete. New maximal polygons: 509
[ Info: [i = 11]. Got 38 maximal polygons.
[ Info: [i = 11]. Subpolygons complete. Num of polygons: 6125
[ Info: [i = 11]. Moving out complete. New maximal polygons: 700
[ Info: [i = 12]. Got 51 maximal polygons.
[ Info: [i = 12]. Subpolygons complete. Num of polygons: 8101
[ Info: [i = 12]. Moving out complete. New maximal polygons: 1044
[ Info: [i = 13]. Got 61 maximal polygons.
[ Info: [i = 13]. Subpolygons complete. Num of polygons: 11027
[ Info: [i = 13]. Moving out complete. New maximal polygons: 1113
[ Info: [i = 14]. Got 76 maximal polygons.
[ Info: [i = 14]. Subpolygons complete. Num of polygons: 17280
[ Info: [i = 14]. Moving out complete. New maximal polygons: 1429
[ Info: [i = 15]. Got 86 maximal polygons.
[ Info: [i = 15]. Subpolygons complete. Num of polygons: 21499
[ Info: [i = 15]. Moving out complete. New maximal polygons: 2052
[ Info: [i = 16]. Got 113 maximal polygons.
[ Info: [i = 16]. Subpolygons complete. Num of polygons: 28689
[ Info: [i = 16]. Moving out complete. New maximal polygons: 1962
[ Info: [i = 17]. Got 129 maximal polygons.
[ Info: [i = 17]. Subpolygons complete. Num of polygons: 43012
[ Info: [i = 17]. Moving out complete. New maximal polygons: 2651
[ Info: [i = 18]. Got 166 maximal polygons.
[ Info: [i = 18]. Subpolygons complete. Num of polygons: 52736
[ Info: [i = 18]. Moving out complete. New maximal polygons: 3543
[ Info: [i = 19]. Got 200 maximal polygons.
[ Info: [i = 19]. Subpolygons complete. Num of polygons: 68557
[ Info: [i = 19]. Moving out complete. New maximal polygons: 3638
[ Info: [i = 20]. Got 240 maximal polygons.
[ Info: [i = 20]. Subpolygons complete. Num of polygons: 97733
[ Info: [i = 20]. Moving out complete. New maximal polygons: 4594
[ Info: [i = 21]. Got 281 maximal polygons.
[ Info: [i = 21]. Subpolygons complete. Num of polygons: 117776
[ Info: [i = 21]. Moving out complete. New maximal polygons: 5996
[ Info: [i = 22]. Got 352 maximal polygons.
[ Info: [i = 22]. Subpolygons complete. Num of polygons: 152344
[ Info: [i = 22]. Moving out complete. New maximal polygons: 6364
[ Info: [i = 23]. Got 403 maximal polygons.
[ Info: [i = 23]. Subpolygons complete. Num of polygons: 209409
[ Info: [i = 23]. Moving out complete. New maximal polygons: 7922
[ Info: [i = 24]. Got 506 maximal polygons.
[ Info: [i = 24]. Subpolygons complete. Num of polygons: 248983
[ Info: [i = 24]. Moving out complete. New maximal polygons: 9692
[ Info: [i = 25]. Got 584 maximal polygons.
[ Info: [i = 25]. Subpolygons complete. Num of polygons: 319957
[ Info: [i = 25]. Moving out complete. New maximal polygons: 10208
[ Info: [i = 26]. Got 708 maximal polygons.
[ Info: [i = 26]. Subpolygons complete. Num of polygons: 420714
[ Info: [i = 26]. Moving out complete. New maximal polygons: 12727
[ Info: [i = 27]. Got 821 maximal polygons.
[ Info: [i = 27]. Subpolygons complete. Num of polygons: 497676
[ Info: [i = 27]. Moving out complete. New maximal polygons: 15431
[ Info: [i = 28]. Got 995 maximal polygons.
[ Info: [i = 28]. Subpolygons complete. Num of polygons: 641229
[ Info: [i = 28]. Moving out complete. New maximal polygons: 15918
[ Info: [i = 29]. Got 1121 maximal polygons.
[ Info: [i = 29]. Subpolygons complete. Num of polygons: 813814
[ Info: [i = 29]. Moving out complete. New maximal polygons: 20354
[ Info: [i = 30]. Got 1352 maximal polygons.
[ Info: [i = 30]. Subpolygons complete. Num of polygons: 957001
[ Info: [i = 30]. Moving out complete. New maximal polygons: 23873</code></pre><p><strong>Example</strong></p><p>Reproduce Castryck&#39;s classification and storing the output to HDF5 files</p><pre><code class="language-julia hljs">julia&gt; st = HDFCastryckStorage{Int}(&quot;/tmp&quot;);

julia&gt; classify_lattice_polygons_by_genus(st, 30);</code></pre><p>This will create two directories &quot;all&quot; and &quot;maximal&quot; in the target directory and populate them with HDF5 files &quot;i1.h5, i2.h5, ...&quot; containing the polygons. The files in &quot;maximal&quot; contain datasets ordered by number of vertices. The files in &quot;all&quot; contain groups ordered by area, which contain datasets ordered by number of vertices. Every h5 file additionally contains a dataset &quot;numbers_of_polygons&quot;.</p><pre><code class="language-julia hljs">julia&gt; using HDF5

julia&gt; f = h5open(&quot;/tmp/all/i30.h5&quot;, &quot;r&quot;);

julia&gt; Ps = read_polygon_dataset(1, f, &quot;a69/n8&quot;); # Read in all octagons of genus 30 with normalized volume 69

julia&gt; all(P -&gt; number_of_interior_lattice_points(P) == 30, Ps)
true

julia&gt; A = read_dataset(f, &quot;numbers_of_polygons&quot;); # The total number of lattice polygons with 30 interior lattice points

julia&gt; sum(A) # The total number of lattice polygons with 30 interior lattice points.
957001</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/castryck.jl#L381-L524">source</a></section></article><h2 id="Lattice-polygons-contained-in-a-square"><a class="docs-heading-anchor" href="#Lattice-polygons-contained-in-a-square">Lattice polygons contained in a square</a><a id="Lattice-polygons-contained-in-a-square-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-polygons-contained-in-a-square" title="Permalink"></a></h2><p>In [<a href="../#BK13">6</a>], the authors considered lattice polygons that are contained in a square of fixed side length and classified them up to side length 7. Their numbers (Table 1 of [<a href="../#BK13">6</a>], see also <a href="https://oeis.org/A374975">A374975</a>) can be reproduced with RationalPolygons.jl as follows:</p><pre><code class="language-julia hljs">julia&gt; square(m) = convex_hull(LatticePoint{Int}[(0,0),(m,0),(0,m),(m,m)])
square (generic function with 1 method)

julia&gt; Pss = [subpolygons(square(m); use_affine_normal_form = true, only_equal_number_of_interior_lattice_points = false) for m = 1 : 7];

julia&gt; numbers_of_polygons = [length(Pss[m]) - length(Pss[m-1]) for m = 2 : 7]
6-element Vector{Int64}:
      15
     131
    1369
   13842
  129185
 1104895

julia&gt; max_vertices = [maximum(number_of_vertices.(Pss[m])) for m = 1 : 7]
7-element Vector{Int64}:
  4
  6
  8
  9
 10
 12
 13

julia&gt; [length(filter(P -&gt; number_of_vertices(P) == max_vertices[m], Pss[m])) for m = 1 : 7]
7-element Vector{Int64}:
  1
  1
  1
  1
 15
  2
  3</code></pre><h2 id="Maximal-rational-polygons-contained-in-\\mathbb{R}\\times[-1,1]"><a class="docs-heading-anchor" href="#Maximal-rational-polygons-contained-in-\\mathbb{R}\\times[-1,1]">Maximal rational polygons contained in <span>$\mathbb{R}\times[-1,1]$</span></a><a id="Maximal-rational-polygons-contained-in-\\mathbb{R}\\times[-1,1]-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-rational-polygons-contained-in-\\mathbb{R}\\times[-1,1]" title="Permalink"></a></h2><p>Here we provide an implementation for Algorithm 3.4 of [<a href="../#BS24">1</a>].</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_polygons_m1p1" href="#RationalPolygons.classify_maximal_polygons_m1p1"><code>RationalPolygons.classify_maximal_polygons_m1p1</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_polygons_m1p1(k :: T, i :: Int)</code></pre><p>Return all maximal <code>k</code>-rational polygons with <code>i</code> interior lattice points that can be realized in <span>$\mathbb{R} \times [-1,1]$</span>.</p><p><strong>Example</strong></p><p>Compute the numbers of polygons for <code>1 ≤ k ≤ 5</code> and <code>0 ≤ i ≤ 10</code>. </p><pre><code class="language-julia-repl hljs">julia&gt; [length(classify_maximal_polygons_m1p1(k,i)) for k = 1 : 5, i = 0 :10]
5×11 Matrix{Int64}:
  1    2    4    5    6    7    8    9   10   11   12
  4    9   13   18   22   26   30   34   38   42   46
 12   26   41   54   68   81   94  107  120  133  146
 24   57   86  117  145  174  203  231  259  288  316
 54  132  209  280  353  422  493  562  631  701  771</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/collinear_interior_points.jl#L2-L22">source</a></section></article><h2 id="Maximal-rational-polygons-with-no-interior-lattice-points"><a class="docs-heading-anchor" href="#Maximal-rational-polygons-with-no-interior-lattice-points">Maximal rational polygons with no interior lattice points</a><a id="Maximal-rational-polygons-with-no-interior-lattice-points-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-rational-polygons-with-no-interior-lattice-points" title="Permalink"></a></h2><p>Here, we provide an implementation for Algorithm 4.4 of [<a href="../#BS24">1</a>].</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_squares" href="#RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_squares"><code>RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_squares</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_lattice_free_polygons_m1p2_squares(k :: T) where {T &lt;: Integer}</code></pre><p>Return all <code>k</code>-maximal polygons with no interior lattice points that are contained in <span>$A \cup \mathbb{R} \times [-1,2] \cup B$</span> where <span>$A$</span> is the square with vertices <span>$(0,1),(1,1),(1,2),(0,2)$</span> and B is the square with vertices <span>$(0,0),(0,-1),(1,-1),(1,0)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/no_interior_lattice_points.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_trapezoids" href="#RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_trapezoids"><code>RationalPolygons.classify_maximal_lattice_free_polygons_m1p2_trapezoids</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_lattice_free_polygons_m1p2_trapezoids(k :: T) where {T &lt;: Integer}</code></pre><p>Return all <code>k</code>-maximal polygons with no interior lattice points that are contained in <span>$A \cup \mathbb{R} \times [-1,2] \cup B$</span> where <span>$A$</span> is the trapezoid with vertices <span>$(-1,2),(0,1),(1,1),(1,2)$</span> and <span>$B$</span> is the trapezoid with vertices <span>$(0,0),(0,-1),(2,-1),(1,0)$</span>, excluding the polygons from <code>classify_maximal_lattice_free_polygons_m1p2_squares</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/no_interior_lattice_points.jl#L65-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_lattice_free_polygons_m1p2" href="#RationalPolygons.classify_maximal_lattice_free_polygons_m1p2"><code>RationalPolygons.classify_maximal_lattice_free_polygons_m1p2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_lattice_free_polygons_m1p2(k :: T) where {T &lt;: Integer}</code></pre><p>Return all <code>k</code>-maximal polygons with no interior lattice points contained in <span>$\mathbb{R} \times [-1,2]$</span>. This is simply the union of <code>classify_maximal_lattice_free_polygons_m1p2_squares</code> and <code>classify_maximal_lattice_free_polygons_m1p2_trapezoids</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/no_interior_lattice_points.jl#L126-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_lattice_free_polygons" href="#RationalPolygons.classify_maximal_lattice_free_polygons"><code>RationalPolygons.classify_maximal_lattice_free_polygons</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_lattice_free_polygons(k :: T ; logging = false) where {T &lt;: Integer}</code></pre><p>Return all <code>k</code>-rational polygons with no interior lattice points.</p><p><strong>Example</strong></p><p>Compute the numbers of polygons for <code>1 ≤ k ≤ 6</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; length.(classify_maximal_lattice_free_polygons.(1:6))
6-element Vector{Int64}:
   1
   4
  14
  39
 134
 299</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/no_interior_lattice_points.jl#L140-L160">source</a></section></article><h2 id="Rational-polygons-with-one-interior-lattice-point"><a class="docs-heading-anchor" href="#Rational-polygons-with-one-interior-lattice-point">Rational polygons with one interior lattice point</a><a id="Rational-polygons-with-one-interior-lattice-point-1"></a><a class="docs-heading-anchor-permalink" href="#Rational-polygons-with-one-interior-lattice-point" title="Permalink"></a></h2><p>Here, we provide an implementation of Algorithm 5.4 of [<a href="../#BS24">1</a>].</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_polygons_genus_one_m1p1" href="#RationalPolygons.classify_maximal_polygons_genus_one_m1p1"><code>RationalPolygons.classify_maximal_polygons_genus_one_m1p1</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_polygons_genus_one_m1p1(k :: T) where {T &lt;: Integer}</code></pre><p>Return all maximal <code>k</code>-rational polygons with exactly one interior lattice point that can be realized in <span>$\mathbb{R} \times [-1,1]$</span>. If <code>primitive = true</code> is passed, then only primitive polygons (i.e. ldp polygons) are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/one_interior_lattice_point.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_polygons_genus_one_m1p2" href="#RationalPolygons.classify_maximal_polygons_genus_one_m1p2"><code>RationalPolygons.classify_maximal_polygons_genus_one_m1p2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_polygons_genus_one_m1p2(k :: T) where {T &lt;: Integer}</code></pre><p>Return all maximal <code>k</code>-rational polygons with exactly one interior lattice point that can be realized in <span>$\mathbb{R} \times [-1,2]$</span>. If <code>primitive = true</code> is passed, then only primitive polygons (i.e. ldp polygons) are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/one_interior_lattice_point.jl#L53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_polygons_genus_one_m2p2" href="#RationalPolygons.classify_maximal_polygons_genus_one_m2p2"><code>RationalPolygons.classify_maximal_polygons_genus_one_m2p2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_polygons_genus_one_m2p2(k :: T, q :: Int) where {T &lt;: Integer}</code></pre><p>Return all maximal <code>k</code>-rational polygons with exactly one interior lattice point that can be realized in <span>$\mathbb{R} \times [-2,2]$</span> that have non-empty intersection with the <code>q</code>-th classification box, where <code>1 ≤ q ≤ 3</code>. If <code>primitive = true</code> is passed, then only primitive polygons (i.e. ldp polygons) are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/one_interior_lattice_point.jl#L132-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_maximal_polygons_genus_one" href="#RationalPolygons.classify_maximal_polygons_genus_one"><code>RationalPolygons.classify_maximal_polygons_genus_one</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_maximal_polygons_genus_one(k :: T) where {T &lt;: Integer}</code></pre><p>Return all maximal <code>k</code>-rational polygons with exactly one interior lattice point. If <code>primitive = true</code> is passed, then only primitive polygons (i.e. ldp polygons) are returned.</p><p><strong>Example</strong></p><p>Compute the numbers of polygons for <span>$k ≤ 3$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; length.(classify_maximal_polygons_genus_one.(1:3))
4-element Vector{Int64}:
   3
  10
  39</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/one_interior_lattice_point.jl#L279-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RationalPolygons.classify_polygons_genus_one" href="#RationalPolygons.classify_polygons_genus_one"><code>RationalPolygons.classify_polygons_genus_one</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_polygons_genus_one(k :: T) where {T &lt;: Integer}</code></pre><p>Compute all <code>k</code>-rational polygons with exactly one interior lattice point. The following keyword arguments are supported:</p><ul><li><code>primitive :: Bool</code>. If set to true, only primitive polygons (i.e. ldp polygons) are returned.</li><li><code>logging :: Bool</code>. Controls whether to display logging messages showing the</li></ul><p>current progress.</p><p><strong>Example</strong></p><p>Reproduce the classifcation of all 5145 half-integral polygons with exactly one interior lattice point. It first computes all maximal polygons with <code>classify_maximal_polygons_genus_one</code> and then generates all their subpolygons.</p><pre><code class="language-julia-repl hljs">julia&gt; classify_polygons_genus_one(2; logging=true);
[ Info: Found 9 maximal polygons in QQ x [-1,1]. New: 9, total: 9
[ Info: Found 2 maximal polygons in QQ x [-1,2]. New: 1, total: 10
[ Info: Found 0 maximal polygons in QQ x [-2,2], box 1. New: 0, total: 10
[ Info: Found 3 maximal polygons in QQ x [-2,2], box 2. New: 0, total: 10
[ Info: Found 3 maximal polygons in QQ x [-2,2], box 3. New: 0, total: 10
[ Info: [a = 36]. Polygons to peel: 2.
[ Info: [a = 36]. Peeling complete. New polygons: 2. Running total: 12
[ Info: [a = 35]. Polygons to peel: 2.
[ Info: [a = 35]. Peeling complete. New polygons: 5. Running total: 17
[ Info: [a = 34]. Polygons to peel: 5.
[ Info: [a = 34]. Peeling complete. New polygons: 10. Running total: 27
[ Info: [a = 33]. Polygons to peel: 9.
[ Info: [a = 33]. Peeling complete. New polygons: 19. Running total: 46
[ Info: [a = 32]. Polygons to peel: 23.
[ Info: [a = 32]. Peeling complete. New polygons: 45. Running total: 91
[ Info: [a = 31]. Polygons to peel: 31.
[ Info: [a = 31]. Peeling complete. New polygons: 69. Running total: 160
[ Info: [a = 30]. Polygons to peel: 60.
[ Info: [a = 30]. Peeling complete. New polygons: 115. Running total: 275
[ Info: [a = 29]. Polygons to peel: 84.
[ Info: [a = 29]. Peeling complete. New polygons: 170. Running total: 445
[ Info: [a = 28]. Polygons to peel: 137.
[ Info: [a = 28]. Peeling complete. New polygons: 239. Running total: 684
[ Info: [a = 27]. Polygons to peel: 171.
[ Info: [a = 27]. Peeling complete. New polygons: 285. Running total: 969
[ Info: [a = 26]. Polygons to peel: 240.
[ Info: [a = 26]. Peeling complete. New polygons: 364. Running total: 1333
[ Info: [a = 25]. Polygons to peel: 286.
[ Info: [a = 25]. Peeling complete. New polygons: 440. Running total: 1773
[ Info: [a = 24]. Polygons to peel: 356.
[ Info: [a = 24]. Peeling complete. New polygons: 466. Running total: 2239
[ Info: [a = 23]. Polygons to peel: 351.
[ Info: [a = 23]. Peeling complete. New polygons: 433. Running total: 2672
[ Info: [a = 22]. Polygons to peel: 396.
[ Info: [a = 22]. Peeling complete. New polygons: 439. Running total: 3111
[ Info: [a = 21]. Polygons to peel: 391.
[ Info: [a = 21]. Peeling complete. New polygons: 394. Running total: 3505
[ Info: [a = 20]. Polygons to peel: 390.
[ Info: [a = 20]. Peeling complete. New polygons: 338. Running total: 3843
[ Info: [a = 19]. Polygons to peel: 349.
[ Info: [a = 19]. Peeling complete. New polygons: 269. Running total: 4112
[ Info: [a = 18]. Polygons to peel: 357.
[ Info: [a = 18]. Peeling complete. New polygons: 249. Running total: 4361
[ Info: [a = 17]. Polygons to peel: 301.
[ Info: [a = 17]. Peeling complete. New polygons: 215. Running total: 4576
[ Info: [a = 16]. Polygons to peel: 292.
[ Info: [a = 16]. Peeling complete. New polygons: 178. Running total: 4754
[ Info: [a = 15]. Polygons to peel: 233.
[ Info: [a = 15]. Peeling complete. New polygons: 121. Running total: 4875
[ Info: [a = 14]. Polygons to peel: 191.
[ Info: [a = 14]. Peeling complete. New polygons: 91. Running total: 4966
[ Info: [a = 13]. Polygons to peel: 140.
[ Info: [a = 13]. Peeling complete. New polygons: 71. Running total: 5037
[ Info: [a = 12]. Polygons to peel: 121.
[ Info: [a = 12]. Peeling complete. New polygons: 40. Running total: 5077
[ Info: [a = 11]. Polygons to peel: 67.
[ Info: [a = 11]. Peeling complete. New polygons: 21. Running total: 5098
[ Info: [a = 10]. Polygons to peel: 56.
[ Info: [a = 10]. Peeling complete. New polygons: 14. Running total: 5112
[ Info: [a = 9]. Polygons to peel: 38.
[ Info: [a = 9]. Peeling complete. New polygons: 13. Running total: 5125
[ Info: [a = 8]. Polygons to peel: 31.
[ Info: [a = 8]. Peeling complete. New polygons: 13. Running total: 5138
[ Info: [a = 7]. Polygons to peel: 14.
[ Info: [a = 7]. Peeling complete. New polygons: 3. Running total: 5141
[ Info: [a = 6]. Polygons to peel: 13.
[ Info: [a = 6]. Peeling complete. New polygons: 3. Running total: 5144
[ Info: [a = 5]. Polygons to peel: 4.
[ Info: [a = 5]. Peeling complete. New polygons: 1. Running total: 5145
[ Info: [a = 4]. Polygons to peel: 3.
[ Info: [a = 4]. Peeling complete. New polygons: 0. Running total: 5145
[ Info: [a = 3]. Polygons to peel: 1.
[ Info: [a = 3]. Peeling complete. New polygons: 0. Running total: 5145
[ Info: [a = 2]. Polygons to peel: 0.
[ Info: [a = 2]. Peeling complete. New polygons: 0. Running total: 5145
[ Info: [a = 1]. Polygons to peel: 0.
[ Info: [a = 1]. Peeling complete. New polygons: 0. Running total: 5145</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/justus-springer/RationalPolygons.jl/blob/ef97751467c487c7457e2c9ad315c6472dd2e44a/src/Classification/one_interior_lattice_point.jl#L338-L434">source</a></section></article><h2 id="Almost-k-hollow-LDP-polygons"><a class="docs-heading-anchor" href="#Almost-k-hollow-LDP-polygons">Almost <span>$k$</span>-hollow LDP polygons</a><a id="Almost-k-hollow-LDP-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Almost-k-hollow-LDP-polygons" title="Permalink"></a></h2><p>We can instruct <code>classify_polygons_genus_one</code> to only output <code>k</code>-rational polygons with primitive vertices. These are exactly the almost <span>$k$</span>-hollow LDP polygons and they correspond to <span>$1/k$</span>-log canonical toric del Pezzo surfaces. In particular, we can reproduce the classification of the 48032 almost 3-hollow LDP polygons (<span>$1/3$</span>-log canonical toric del Pezzo surfaces) from Theorem 4.11 of [<a href="../#HHS23">7</a>]. See also Table 6 of [<a href="../#BS24">1</a>] for the classification up to <span>$k = 6$</span>.</p><pre><code class="language-julia hljs">julia&gt; Pss = [classify_polygons_genus_one(k; primitive=true) for k = 1 : 3];

julia&gt; numbers_of_polygons = length.(Pss)
3-element Vector{Int64}:
    16
   505
 48032

julia&gt; max_vertices = [maximum(number_of_vertices.(Pss[k])) for k = 1 : 3]
3-element Vector{Int64}:
  6
  8
 12

julia&gt; max_volumes = [k^2 * maximum(euclidian_area.(Pss[k])) for k = 1 : 3]
3-element Vector{Rational{Int64}}:
 9//2
 17
 47</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../subpolygons/">« Subpolygons</a><a class="docs-footer-nextpage" href="../docs_index/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 11 September 2024 14:07">Wednesday 11 September 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
